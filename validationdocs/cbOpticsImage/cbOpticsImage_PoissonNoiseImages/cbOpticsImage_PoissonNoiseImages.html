
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>cbOpticsImage_PoissonNoiseImages</title><meta name="generator" content="MATLAB 8.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2015-07-29"><meta name="DC.source" content="cbOpticsImage_PoissonNoiseImages.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">Function implementing the isetbio validation code</a></li><li><a href="#4">Hello</a></li><li><a href="#5">Supress irritating warnings</a></li><li><a href="#6">Frozen noise, so that we can validate OK</a></li><li><a href="#7">Load a hyperspectral scene in ISETBIO format.</a></li><li><a href="#8">Parameters</a></li><li><a href="#9">The scene object has a view about what the illuminant is.</a></li><li><a href="#10">Make optical image</a></li><li><a href="#11">Figure out optical image cropping parameters</a></li><li><a href="#12">Look at scene and oi sRGB images</a></li><li><a href="#13">Get the retinal irradiance per pixel</a></li><li><a href="#14">Pick an integration time to get photons</a></li><li><a href="#15">Make image noise free at selected wavelength</a></li><li><a href="#16">Make images for different irradiance levels</a></li><li><a href="#17">Save validation data</a></li><li><a href="#18">Restore warning state</a></li><li><a href="#20">Restore warning state</a></li><li><a href="#21">Rethrow error</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> varargout = cbOpticsImage_PoissonNoiseImages(varargin)
<span class="comment">%</span>
<span class="comment">% Illustrate magnitude of Poisson noise as a function of light level</span>
<span class="comment">%</span>
<span class="comment">% (c) David Brainard and Andrew Stockman, 2015</span>

varargout = UnitTest.runValidationRun(@ValidationFunction, nargout, varargin);
<span class="keyword">end</span>
</pre><h2>Function implementing the isetbio validation code<a name="2"></a></h2><pre class="codeinput"><span class="keyword">function</span> ValidationFunction(runTimeParams)
</pre><h2>Hello<a name="4"></a></h2><pre class="codeinput">clear <span class="string">global</span>; ieInit;
UnitTest.validationRecord(<span class="string">'SIMPLE_MESSAGE'</span>, sprintf(<span class="string">'%s'</span>,mfilename));
outputDir = sprintf(<span class="string">'%s_Output'</span>,mfilename);
<span class="keyword">if</span> (~exist(outputDir,<span class="string">'dir'</span>))
    mkdir(outputDir);
<span class="keyword">end</span>
</pre><h2>Supress irritating warnings<a name="5"></a></h2><pre class="codeinput">warnS = warning(<span class="string">'off'</span>,<span class="string">'images:initSize:adjustingMag'</span>);

<span class="keyword">try</span>
</pre><h2>Frozen noise, so that we can validate OK<a name="6"></a></h2><pre class="codeinput">    randomSeedValue = 26;
    rng(randomSeedValue);
</pre><h2>Load a hyperspectral scene in ISETBIO format.<a name="7"></a></h2><pre class="codeinput">    theHyperSceneDir = <span class="string">'/Volumes/Users1/Shared/Matlab/Analysis/hyperspectral-images/manchester_database'</span>;
    theHyperSceneName = <span class="string">'isetbioSceneFor_scene7.mat'</span>;
    theData = load(fullfile(theHyperSceneDir,theHyperSceneName));
    theData.sceneRGBImage = sceneGet(theData.scene,<span class="string">'rgb image'</span>);
    <span class="comment">% vcAddAndSelectObject(theData.scene); sceneWindow;</span>
</pre><h2>Parameters<a name="8"></a></h2><pre class="codeinput">    theData.whichWavelength = 550;
    meanScalar = 0.2;
    displayGamma = 0.5;
    theIrradianceScaleFactors = [1e-3 1e-2 1e-1 1];
</pre><h2>The scene object has a view about what the illuminant is.<a name="9"></a></h2><p>Get this to help us set a reasonable physical scale for the scene.</p><pre class="codeinput">    sceneWave = sceneGet(theData.scene,<span class="string">'wave'</span>);
    sceneWlIndex = find(sceneWave == theData.whichWavelength);
    sceneS = WlsToS(sceneWave);
    theData.sceneIlluminantSpdRadiance_WattsPerM2SrNm = sceneGet(theData.scene,<span class="string">'illuminant energy'</span>);
    theData.sceneIlluminantSpdRadiance_QuantaPerSecM2SrNm = sceneGet(theData.scene,<span class="string">'illuminant photons'</span>);
    sceneIlluminantXYZ = sceneGet(theData.scene,<span class="string">'illuminant XYZ'</span>);
    load <span class="string">T_xyz1931</span>;
    T_xyz = SplineCmf(S_xyz1931,T_xyz1931,sceneS);
    ourSceneIlluminantXYZ = 683*T_xyz*theData.sceneIlluminantSpdRadiance_WattsPerM2SrNm*sceneS(2);
    theData.sceneIlluminantTotalIrradiance_WattsPerM2 = 2*pi*sum(theData.sceneIlluminantSpdRadiance_WattsPerM2SrNm*sceneS(2));
    theData.sceneIlluminantTotalIrradiance_QuantaPerSecM2 = 2*pi*sum(theData.sceneIlluminantSpdRadiance_QuantaPerSecM2SrNm*sceneS(2));

    <span class="comment">% Plot the illuminant spectrum</span>
    <span class="keyword">if</span> (runTimeParams.generatePlots)

        [illumSpdFig,figParams] = cbFigInit;
        figParams.xLimLow = 350;
        figParams.xLimHigh = 750;
        figParams.xTicks = [350 400 450 500 550 600 650 700 750];
        figParams.xTickLabels = {<span class="string">'^{ }350_{ }'</span> <span class="string">'^{ }400_{ }'</span> <span class="string">'^{ }450_{ }'</span> <span class="string">'^{ }500_{ }'</span> <span class="keyword">...</span>
        <span class="string">'^{ }550_{ }'</span> <span class="string">'^{ }600_{ }'</span> <span class="string">'^{ }650_{ }'</span> <span class="string">'^{ }700_{ }'</span> <span class="string">'^{ }750_{ }'</span>};
        figParams.yLimLow = 0;
        figParams.yLimHigh = 2e19;
        figParams.yTicks = [0 0.5e19 1.0e19 1.5e19 2.0e19];
        figParams.yTickLabels = {<span class="string">'  0.0 '</span> <span class="string">' 0.5 '</span> <span class="string">' 1.0 '</span> <span class="string">' 1.5 '</span> <span class="string">' 2.0 '</span>};

        plot(sceneWave,2*pi*theData.sceneIlluminantSpdRadiance_QuantaPerSecM2SrNm,<span class="string">'r'</span>,<span class="string">'LineWidth'</span>,figParams.lineWidth);

        xlabel(<span class="string">'Wavelength (nm)'</span>,<span class="string">'FontSize'</span>,figParams.labelFontSize);
        ylabel(<span class="string">'Irradiance (quanta/[sec-m^{2}-nm])'</span>,<span class="string">'FontSize'</span>,figParams.labelFontSize);
        title(<span class="string">'Scene Illuminant SPD'</span>,<span class="string">'FontSize'</span>,figParams.titleFontSize);
        cbFigAxisSet(illumSpdFig,figParams);
        text(345,2.075e19,<span class="string">'\times10^{19}'</span>,<span class="string">'FontName'</span>,figParams.fontName,<span class="string">'FontSize'</span>,figParams.axisFontSize);

        FigureSave(fullfile(outputDir,[mfilename <span class="string">'_IlluminantQuantalUnits'</span>]),illumSpdFig,figParams.figType);
    <span class="keyword">end</span>

    UnitTest.assertIsZero(max(abs(sceneIlluminantXYZ(:)-ourSceneIlluminantXYZ(:))),<span class="string">'Check on XYZ computation'</span>,0.1);
    sceneFov = sceneGet(theData.scene,<span class="string">'horizontal fov'</span>);
    fprintf(<span class="string">'Scene field of view (horizontal) is %0.1f degrees\n'</span>,sceneFov);
    fprintf(<span class="string">'Scene illumination luminance taken as %0.0f cd/m2\n'</span>,sceneIlluminantXYZ(2));
    fprintf(<span class="string">'Scene illuminant irradiance at selected wavelength (%d nm) is %0.2g quanta/[sec-m2-nm]\n'</span>, <span class="keyword">...</span>
        theData.whichWavelength,2*pi*theData.sceneIlluminantSpdRadiance_QuantaPerSecM2SrNm(sceneWlIndex));
    fprintf(<span class="string">'Scene illuminant total irradiance %0.2g Watts/m2, %0.2g quanta/[sec-m2]\n'</span>,<span class="keyword">...</span>
        theData.sceneIlluminantTotalIrradiance_WattsPerM2,theData.sceneIlluminantTotalIrradiance_QuantaPerSecM2);
</pre><pre class="codeoutput">Scene field of view (horizontal) is 5.6 degrees
Scene illumination luminance taken as 58126 cd/m2
Scene illuminant irradiance at selected wavelength (550 nm) is 1.4e+19 quanta/[sec-m2-nm]
Scene illuminant total irradiance 1.5e+03 Watts/m2, 4.3e+21 quanta/[sec-m2]
</pre><img vspace="5" hspace="5" src="cbOpticsImage_PoissonNoiseImages_01.png" alt=""> <h2>Make optical image<a name="10"></a></h2><p>We do this to get retinal irradiance, and for the first part of this script we only want photon noise so we skip the blurring.  THere are built in ways to skip the blurring, but they have side effects that currently surprise me.  So we just set an OTF off all ones and get on with life.</p><pre class="codeinput">    theData.oi = oiCreate(<span class="string">'human'</span>);
    theData.optics = oiGet(theData.oi,<span class="string">'optics'</span>);
    theData.optics = opticsSet(theData.optics,<span class="string">'off axis method'</span>,<span class="string">'skip'</span>);
    OTFData = opticsGet(theData.optics,<span class="string">'otfdata'</span>);
    OTFDeltaData = ones(size(OTFData));
    theData.optics = opticsSet(theData.optics,<span class="string">'otfdata'</span>,OTFDeltaData);
    theData.oi = oiSet(theData.oi,<span class="string">'optics'</span>,theData.optics);
    theData.oi = oiCompute(theData.oi,theData.scene);
    theData.oiRGBImage = oiGet(theData.oi,<span class="string">'rgb image'</span>);
    <span class="comment">% vcAddAndSelectObject(theData.oi); oiWindow;</span>
</pre><h2>Figure out optical image cropping parameters<a name="11"></a></h2><p>The optical image gets padded to allow the OTF convolutions to have something to look at outside the border of the original image.  Figure out here how big this padding is so that we can crop the optical images back to the size of the original scene, give or take a pixel.</p><pre class="codeinput">    [sceneRows,sceneCols] = size(theData.sceneRGBImage(:,:,1));
    [oiRows,oiCols] = size(theData.oiRGBImage(:,:,1));
    extraRows = oiRows - sceneRows;
    extraCols = oiCols - sceneCols;
    cropRows = ceil(extraRows/2):oiRows-ceil(extraRows/2)-1;
    cropCols = ceil(extraCols/2):oiCols-ceil(extraCols/2)-1;
</pre><h2>Look at scene and oi sRGB images<a name="12"></a></h2><p>Because these are normalized and we didn't blur, they look the same.</p><pre class="codeinput">    <span class="keyword">if</span> (runTimeParams.generatePlots)
        figure; clf;
        imshow(theData.sceneRGBImage);
        set(gcf,<span class="string">'Name'</span>,<span class="string">'Scene Radiance sRGB'</span>);
        imwrite(theData.sceneRGBImage,fullfile(outputDir,[mfilename <span class="string">'_SceneRadianceRGB.png'</span>]),<span class="string">'png'</span>);

        figure; clf;
        imshow(theData.oiRGBImage(cropRows,cropCols,:));
        set(gcf,<span class="string">'Name'</span>,<span class="string">'Retinal Image sRGB'</span>);
        imwrite(theData.oiRGBImage(cropRows,cropCols,:),fullfile(outputDir,[mfilename <span class="string">'_RetinalIrradianceRGB.png'</span>]),<span class="string">'png'</span>);
    <span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="cbOpticsImage_PoissonNoiseImages_02.png" alt=""> <img vspace="5" hspace="5" src="cbOpticsImage_PoissonNoiseImages_03.png" alt=""> <h2>Get the retinal irradiance per pixel<a name="13"></a></h2><pre class="codeinput">    oiWave = oiGet(theData.oi,<span class="string">'wave'</span>);
    oiWlIndex = find(oiWave == theData.whichWavelength);
    theData.oiIrradiance_PhotonsPerSecM2Nm = double(oiGet(theData.oi,<span class="string">'photons'</span>));
    oiPixelSize_M = oiGet(theData.oi,<span class="string">'sample spacing'</span>);
    oiPixelArea_M2 = oiPixelSize_M(1)*oiPixelSize_M(2);
    oiIrradiance_PhotonsPerSecPixel = theData.oiIrradiance_PhotonsPerSecM2Nm*oiPixelArea_M2;
    oiFov = oiGet(theData.oi,<span class="string">'fov'</span>);
    fprintf(<span class="string">'Optical image field of view (horizontal) is %0.1f degrees\n'</span>,oiFov);
    fprintf(<span class="string">'Pixel size is %0.2f by %0.2f um\n'</span>,oiPixelSize_M(1)*1e6,oiPixelSize_M(2)*1e6);
    fprintf(<span class="string">'Pixel area is %0.2f um\n'</span>,oiPixelArea_M2*1e12);

    <span class="comment">% Print mean/maximum irradiance, as a check</span>
    temp = theData.oiIrradiance_PhotonsPerSecM2Nm(cropRows,cropCols,:);
    meanIrradiance_PhotonsPOerSecM2 = mean(temp(:));
    maxIrradiance_PhotonsPOerSecM2 = max(temp(:));

    temp = theData.oiIrradiance_PhotonsPerSecM2Nm(cropRows,cropCols,oiWlIndex);
    selectedWavelengthIrradiance_PhotonsPerSecM2 = mean(temp(:));
    fprintf(<span class="string">'Mean retinal illuminance at selected wavelength (%d nm) is %0.2g quanta/[sec-m2]\n'</span>,theData.whichWavelength,selectedWavelengthIrradiance_PhotonsPerSecM2);
    fprintf(<span class="string">'Mean optical image irradiance is %0.2g quanta/[sec-m2-nm]; max is %0.2g\n'</span>,meanIrradiance_PhotonsPOerSecM2,maxIrradiance_PhotonsPOerSecM2);
</pre><pre class="codeoutput">Optical image field of view (horizontal) is 6.9 degrees
Pixel size is 1.24 by 1.24 um
Pixel area is 1.53 um
Mean retinal illuminance at selected wavelength (550 nm) is 1.6e+15 quanta/[sec-m2]
Mean optical image irradiance is 1.5e+15 quanta/[sec-m2-nm]; max is 1.2e+16
</pre><h2>Pick an integration time to get photons<a name="14"></a></h2><pre class="codeinput">    theData.integrationTime_Sec = 0.050;
    oiEnergy_PhotonsPerPixel = oiIrradiance_PhotonsPerSecPixel*theData.integrationTime_Sec;
</pre><h2>Make image noise free at selected wavelength<a name="15"></a></h2><pre class="codeinput">    meanPhotons0 = double(oiEnergy_PhotonsPerPixel(:,:,oiWlIndex));
    scaledMeanPhotons0 = meanScalar*meanPhotons0/mean(meanPhotons0(:));
    <span class="keyword">if</span> (runTimeParams.generatePlots)
        figure; clf;
        imshow(scaledMeanPhotons0(cropRows,cropCols,:).^displayGamma);
        set(gcf,<span class="string">'Name'</span>,<span class="string">'No noise'</span>);
        imwrite(scaledMeanPhotons0(cropRows,cropCols,:).^displayGamma,<span class="keyword">...</span>
            fullfile(outputDir,[mfilename <span class="string">'_NoNoiseImageAtWavelength.png'</span>]),<span class="string">'png'</span>);
    <span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="cbOpticsImage_PoissonNoiseImages_04.png" alt=""> <h2>Make images for different irradiance levels<a name="16"></a></h2><pre class="codeinput">    <span class="keyword">if</span> (runTimeParams.generatePlots)
        noiseFigure = figure; clf;
        set(gcf,<span class="string">'Position'</span>,[81 114 1100 1100]);
    <span class="keyword">end</span>
    <span class="keyword">for</span> ii = 1:length(theIrradianceScaleFactors)
        <span class="comment">% Get mean number of photons at each pixel at the desired wavelength</span>
        <span class="comment">% and irradiance scale factor</span>
        meanPhotons = theIrradianceScaleFactors(ii)*double(oiEnergy_PhotonsPerPixel(:,:,oiWlIndex));

        <span class="comment">% Get a draw of Poisson noise around the mean</span>
        noisyPhotons = poissrnd(meanPhotons);

        <span class="comment">% Scale in a consistent manner for display</span>
        scaledNoisyPhotons = meanScalar*noisyPhotons/mean(meanPhotons(:));

        <span class="comment">% Make a figure</span>
        <span class="keyword">if</span> (runTimeParams.generatePlots)
            figure(noiseFigure);
            subplot_tight(2,2,ii,0.02);
            imshow(scaledNoisyPhotons(cropRows,cropCols,:).^displayGamma);
            title(sprintf(<span class="string">'%0.2g quanta/sec-m^{2}'</span>,theIrradianceScaleFactors(ii)*2*pi*theData.sceneIlluminantSpdRadiance_QuantaPerSecM2SrNm(sceneWlIndex)), <span class="keyword">...</span>
                <span class="string">'FontName'</span>,figParams.fontName,<span class="string">'FontSize'</span>,figParams.titleFontSize-2);
        <span class="keyword">end</span>

        <span class="comment">% Check.  Isetbio can gives us a photon noised image, so when the scale</span>
        <span class="comment">% factor is unity we generate that too and have a look.  That returns</span>
        <span class="comment">% the value for a 50 msec integration time and one pixel.</span>
        CHECK = false;
        <span class="keyword">if</span> (CHECK &amp; theIrradianceScaleFactors(ii) == 1 &amp; theData.integrationTime_Sec == 0.050)
            <span class="comment">% Let oiGet do its thing</span>
            noisyPhotonsISETBIO = oiGet(theData.oi,<span class="string">'photons noise'</span>);
            noisyPhotonsISETBIO = double(noisyPhotonsISETBIO(:,:,oiWlIndex));

            <span class="comment">% Scale</span>
            scaledNoisyPhotonsISETBIO = meanScalar*noisyPhotonsISETBIO/mean(meanPhotons(:));

            <span class="comment">% Make a figure</span>
            <span class="keyword">if</span> (runTimeParams.generatePlots)
                figure; clf;
                imshow(scaledNoisyPhotonsISETBIO(cropRows,cropCols,:).^displayGamma);
                set(gcf,<span class="string">'Name'</span>,<span class="string">'ISETBIO noisy photons return'</span>);
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">% Save the figure of the images</span>
    <span class="keyword">if</span> (runTimeParams.generatePlots)
        figure(noiseFigure);

        <span class="comment">% Try to add a title to the subplot montage, but it isn't working</span>
        <span class="comment">% for me easily.  Not sure why, as suplabel has worked for me in</span>
        <span class="comment">% other situations.</span>
        <span class="comment">% [~,h] = suplabel('Poisson Photon Noise','t');</span>
        <span class="comment">% set(h,'FontName',figParams.fontName,'FontSize',figParams.titleFontSize);</span>

        <span class="comment">% Save the PDF</span>
        FigureSave(fullfile(outputDir,[mfilename <span class="string">'_NoiseImageFigure'</span>]),noiseFigure,<span class="string">'png'</span>);
    <span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="cbOpticsImage_PoissonNoiseImages_05.png" alt=""> <h2>Save validation data<a name="17"></a></h2><p>Strip out some of the really big stuff.</p><pre class="codeinput">    theData = rmfield(theData,<span class="string">'scene'</span>);
    theData = rmfield(theData,<span class="string">'oi'</span>);
    theData.partialIrradiance = theData.oiIrradiance_PhotonsPerSecM2Nm(1:10,100:110,8);
    theData = rmfield(theData,<span class="string">'oiIrradiance_PhotonsPerSecM2Nm'</span>);
    UnitTest.validationData(<span class="string">'theData'</span>, theData);
</pre><h2>Restore warning state<a name="18"></a></h2><pre class="codeinput">    warning(warnS.state,warnS.identifier);
</pre><pre class="codeinput"><span class="keyword">catch</span> err
</pre><h2>Restore warning state<a name="20"></a></h2><pre class="codeinput">    warning(warnS.state,warnS.identifier);
</pre><h2>Rethrow error<a name="21"></a></h2><pre class="codeinput">    rethrow(err);
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2014b</a><br></p></div><!--
##### SOURCE BEGIN #####
function varargout = cbOpticsImage_PoissonNoiseImages(varargin)
%
% Illustrate magnitude of Poisson noise as a function of light level
%
% (c) David Brainard and Andrew Stockman, 2015

varargout = UnitTest.runValidationRun(@ValidationFunction, nargout, varargin);
end

%% Function implementing the isetbio validation code
function ValidationFunction(runTimeParams)

%% Hello
clear global; ieInit;
UnitTest.validationRecord('SIMPLE_MESSAGE', sprintf('%s',mfilename));
outputDir = sprintf('%s_Output',mfilename);
if (~exist(outputDir,'dir'))
    mkdir(outputDir);
end

%% Supress irritating warnings
warnS = warning('off','images:initSize:adjustingMag');

try
    %% Frozen noise, so that we can validate OK
    randomSeedValue = 26;
    rng(randomSeedValue);

    %% Load a hyperspectral scene in ISETBIO format.
    theHyperSceneDir = '/Volumes/Users1/Shared/Matlab/Analysis/hyperspectral-images/manchester_database';
    theHyperSceneName = 'isetbioSceneFor_scene7.mat';
    theData = load(fullfile(theHyperSceneDir,theHyperSceneName));
    theData.sceneRGBImage = sceneGet(theData.scene,'rgb image');
    % vcAddAndSelectObject(theData.scene); sceneWindow;

    %% Parameters
    theData.whichWavelength = 550;
    meanScalar = 0.2;
    displayGamma = 0.5;
    theIrradianceScaleFactors = [1e-3 1e-2 1e-1 1];
    
    %% The scene object has a view about what the illuminant is.
    %
    % Get this to help us set a reasonable physical scale for the scene.
    sceneWave = sceneGet(theData.scene,'wave');
    sceneWlIndex = find(sceneWave == theData.whichWavelength);
    sceneS = WlsToS(sceneWave);
    theData.sceneIlluminantSpdRadiance_WattsPerM2SrNm = sceneGet(theData.scene,'illuminant energy');
    theData.sceneIlluminantSpdRadiance_QuantaPerSecM2SrNm = sceneGet(theData.scene,'illuminant photons');
    sceneIlluminantXYZ = sceneGet(theData.scene,'illuminant XYZ');
    load T_xyz1931;
    T_xyz = SplineCmf(S_xyz1931,T_xyz1931,sceneS);
    ourSceneIlluminantXYZ = 683*T_xyz*theData.sceneIlluminantSpdRadiance_WattsPerM2SrNm*sceneS(2);
    theData.sceneIlluminantTotalIrradiance_WattsPerM2 = 2*pi*sum(theData.sceneIlluminantSpdRadiance_WattsPerM2SrNm*sceneS(2));
    theData.sceneIlluminantTotalIrradiance_QuantaPerSecM2 = 2*pi*sum(theData.sceneIlluminantSpdRadiance_QuantaPerSecM2SrNm*sceneS(2));
    
    % Plot the illuminant spectrum
    if (runTimeParams.generatePlots)
        
        [illumSpdFig,figParams] = cbFigInit;
        figParams.xLimLow = 350;
        figParams.xLimHigh = 750;
        figParams.xTicks = [350 400 450 500 550 600 650 700 750];
        figParams.xTickLabels = {'^{ }350_{ }' '^{ }400_{ }' '^{ }450_{ }' '^{ }500_{ }' ...
        '^{ }550_{ }' '^{ }600_{ }' '^{ }650_{ }' '^{ }700_{ }' '^{ }750_{ }'};
        figParams.yLimLow = 0;
        figParams.yLimHigh = 2e19;
        figParams.yTicks = [0 0.5e19 1.0e19 1.5e19 2.0e19];
        figParams.yTickLabels = {'  0.0 ' ' 0.5 ' ' 1.0 ' ' 1.5 ' ' 2.0 '};
        
        plot(sceneWave,2*pi*theData.sceneIlluminantSpdRadiance_QuantaPerSecM2SrNm,'r','LineWidth',figParams.lineWidth);
        
        xlabel('Wavelength (nm)','FontSize',figParams.labelFontSize);
        ylabel('Irradiance (quanta/[sec-m^{2}-nm])','FontSize',figParams.labelFontSize);
        title('Scene Illuminant SPD','FontSize',figParams.titleFontSize);
        cbFigAxisSet(illumSpdFig,figParams);
        text(345,2.075e19,'\times10^{19}','FontName',figParams.fontName,'FontSize',figParams.axisFontSize);
        
        FigureSave(fullfile(outputDir,[mfilename '_IlluminantQuantalUnits']),illumSpdFig,figParams.figType);
    end
    
    UnitTest.assertIsZero(max(abs(sceneIlluminantXYZ(:)-ourSceneIlluminantXYZ(:))),'Check on XYZ computation',0.1);
    sceneFov = sceneGet(theData.scene,'horizontal fov');
    fprintf('Scene field of view (horizontal) is %0.1f degrees\n',sceneFov);
    fprintf('Scene illumination luminance taken as %0.0f cd/m2\n',sceneIlluminantXYZ(2));
    fprintf('Scene illuminant irradiance at selected wavelength (%d nm) is %0.2g quanta/[sec-m2-nm]\n', ...
        theData.whichWavelength,2*pi*theData.sceneIlluminantSpdRadiance_QuantaPerSecM2SrNm(sceneWlIndex));
    fprintf('Scene illuminant total irradiance %0.2g Watts/m2, %0.2g quanta/[sec-m2]\n',...
        theData.sceneIlluminantTotalIrradiance_WattsPerM2,theData.sceneIlluminantTotalIrradiance_QuantaPerSecM2);
    
    %% Make optical image
    %
    % We do this to get retinal irradiance, and for the first part of this
    % script we only want photon noise so we skip the blurring.  THere are
    % built in ways to skip the blurring, but they have side effects that
    % currently surprise me.  So we just set an OTF off all ones and get
    % on with life.
    theData.oi = oiCreate('human');
    theData.optics = oiGet(theData.oi,'optics');
    theData.optics = opticsSet(theData.optics,'off axis method','skip');
    OTFData = opticsGet(theData.optics,'otfdata');
    OTFDeltaData = ones(size(OTFData));
    theData.optics = opticsSet(theData.optics,'otfdata',OTFDeltaData);
    theData.oi = oiSet(theData.oi,'optics',theData.optics);
    theData.oi = oiCompute(theData.oi,theData.scene);
    theData.oiRGBImage = oiGet(theData.oi,'rgb image');
    % vcAddAndSelectObject(theData.oi); oiWindow;
    
    %% Figure out optical image cropping parameters
    %
    % The optical image gets padded to allow the OTF 
    % convolutions to have something to look at outside
    % the border of the original image.  Figure out here
    % how big this padding is so that we can crop the optical
    % images back to the size of the original scene, give or
    % take a pixel.
    [sceneRows,sceneCols] = size(theData.sceneRGBImage(:,:,1));
    [oiRows,oiCols] = size(theData.oiRGBImage(:,:,1));
    extraRows = oiRows - sceneRows;
    extraCols = oiCols - sceneCols;
    cropRows = ceil(extraRows/2):oiRows-ceil(extraRows/2)-1;
    cropCols = ceil(extraCols/2):oiCols-ceil(extraCols/2)-1;
    
    %% Look at scene and oi sRGB images
    %
    % Because these are normalized and we didn't blur, they look the same.
    if (runTimeParams.generatePlots)
        figure; clf;
        imshow(theData.sceneRGBImage);
        set(gcf,'Name','Scene Radiance sRGB');
        imwrite(theData.sceneRGBImage,fullfile(outputDir,[mfilename '_SceneRadianceRGB.png']),'png');
        
        figure; clf;
        imshow(theData.oiRGBImage(cropRows,cropCols,:));
        set(gcf,'Name','Retinal Image sRGB');
        imwrite(theData.oiRGBImage(cropRows,cropCols,:),fullfile(outputDir,[mfilename '_RetinalIrradianceRGB.png']),'png');
    end
    
    %% Get the retinal irradiance per pixel
    oiWave = oiGet(theData.oi,'wave');
    oiWlIndex = find(oiWave == theData.whichWavelength);
    theData.oiIrradiance_PhotonsPerSecM2Nm = double(oiGet(theData.oi,'photons'));
    oiPixelSize_M = oiGet(theData.oi,'sample spacing');
    oiPixelArea_M2 = oiPixelSize_M(1)*oiPixelSize_M(2);
    oiIrradiance_PhotonsPerSecPixel = theData.oiIrradiance_PhotonsPerSecM2Nm*oiPixelArea_M2;
    oiFov = oiGet(theData.oi,'fov');
    fprintf('Optical image field of view (horizontal) is %0.1f degrees\n',oiFov);
    fprintf('Pixel size is %0.2f by %0.2f um\n',oiPixelSize_M(1)*1e6,oiPixelSize_M(2)*1e6);
    fprintf('Pixel area is %0.2f um\n',oiPixelArea_M2*1e12);
    
    % Print mean/maximum irradiance, as a check
    temp = theData.oiIrradiance_PhotonsPerSecM2Nm(cropRows,cropCols,:);
    meanIrradiance_PhotonsPOerSecM2 = mean(temp(:));
    maxIrradiance_PhotonsPOerSecM2 = max(temp(:));
    
    temp = theData.oiIrradiance_PhotonsPerSecM2Nm(cropRows,cropCols,oiWlIndex);
    selectedWavelengthIrradiance_PhotonsPerSecM2 = mean(temp(:));
    fprintf('Mean retinal illuminance at selected wavelength (%d nm) is %0.2g quanta/[sec-m2]\n',theData.whichWavelength,selectedWavelengthIrradiance_PhotonsPerSecM2);
    fprintf('Mean optical image irradiance is %0.2g quanta/[sec-m2-nm]; max is %0.2g\n',meanIrradiance_PhotonsPOerSecM2,maxIrradiance_PhotonsPOerSecM2);
    
    %% Pick an integration time to get photons
    theData.integrationTime_Sec = 0.050;
    oiEnergy_PhotonsPerPixel = oiIrradiance_PhotonsPerSecPixel*theData.integrationTime_Sec;
        
    %% Make image noise free at selected wavelength
    meanPhotons0 = double(oiEnergy_PhotonsPerPixel(:,:,oiWlIndex));
    scaledMeanPhotons0 = meanScalar*meanPhotons0/mean(meanPhotons0(:));
    if (runTimeParams.generatePlots)
        figure; clf;
        imshow(scaledMeanPhotons0(cropRows,cropCols,:).^displayGamma);
        set(gcf,'Name','No noise');
        imwrite(scaledMeanPhotons0(cropRows,cropCols,:).^displayGamma,...
            fullfile(outputDir,[mfilename '_NoNoiseImageAtWavelength.png']),'png');
    end
    
    %% Make images for different irradiance levels
    if (runTimeParams.generatePlots)
        noiseFigure = figure; clf;
        set(gcf,'Position',[81 114 1100 1100]);
    end
    for ii = 1:length(theIrradianceScaleFactors)
        % Get mean number of photons at each pixel at the desired wavelength
        % and irradiance scale factor
        meanPhotons = theIrradianceScaleFactors(ii)*double(oiEnergy_PhotonsPerPixel(:,:,oiWlIndex));
        
        % Get a draw of Poisson noise around the mean
        noisyPhotons = poissrnd(meanPhotons);
        
        % Scale in a consistent manner for display
        scaledNoisyPhotons = meanScalar*noisyPhotons/mean(meanPhotons(:));
        
        % Make a figure
        if (runTimeParams.generatePlots)
            figure(noiseFigure);
            subplot_tight(2,2,ii,0.02);
            imshow(scaledNoisyPhotons(cropRows,cropCols,:).^displayGamma);
            title(sprintf('%0.2g quanta/sec-m^{2}',theIrradianceScaleFactors(ii)*2*pi*theData.sceneIlluminantSpdRadiance_QuantaPerSecM2SrNm(sceneWlIndex)), ...
                'FontName',figParams.fontName,'FontSize',figParams.titleFontSize-2);
        end
        
        % Check.  Isetbio can gives us a photon noised image, so when the scale
        % factor is unity we generate that too and have a look.  That returns
        % the value for a 50 msec integration time and one pixel.
        CHECK = false;
        if (CHECK & theIrradianceScaleFactors(ii) == 1 & theData.integrationTime_Sec == 0.050)
            % Let oiGet do its thing
            noisyPhotonsISETBIO = oiGet(theData.oi,'photons noise');
            noisyPhotonsISETBIO = double(noisyPhotonsISETBIO(:,:,oiWlIndex));
            
            % Scale
            scaledNoisyPhotonsISETBIO = meanScalar*noisyPhotonsISETBIO/mean(meanPhotons(:));
            
            % Make a figure
            if (runTimeParams.generatePlots)
                figure; clf;
                imshow(scaledNoisyPhotonsISETBIO(cropRows,cropCols,:).^displayGamma);
                set(gcf,'Name','ISETBIO noisy photons return');
            end
        end
    end
    
    % Save the figure of the images
    if (runTimeParams.generatePlots)
        figure(noiseFigure);
        
        % Try to add a title to the subplot montage, but it isn't working
        % for me easily.  Not sure why, as suplabel has worked for me in
        % other situations.
        % [~,h] = suplabel('Poisson Photon Noise','t');
        % set(h,'FontName',figParams.fontName,'FontSize',figParams.titleFontSize);
        
        % Save the PDF
        FigureSave(fullfile(outputDir,[mfilename '_NoiseImageFigure']),noiseFigure,'png');
    end
    
    %% Save validation data
    %
    % Strip out some of the really big stuff.
    theData = rmfield(theData,'scene');
    theData = rmfield(theData,'oi');
    theData.partialIrradiance = theData.oiIrradiance_PhotonsPerSecM2Nm(1:10,100:110,8);
    theData = rmfield(theData,'oiIrradiance_PhotonsPerSecM2Nm');
    UnitTest.validationData('theData', theData);
    
    
    %% Restore warning state
    warning(warnS.state,warnS.identifier);
    
catch err
    %% Restore warning state
    warning(warnS.state,warnS.identifier);
    
    %% Rethrow error
    rethrow(err);
end

end



##### SOURCE END #####
--></body></html>