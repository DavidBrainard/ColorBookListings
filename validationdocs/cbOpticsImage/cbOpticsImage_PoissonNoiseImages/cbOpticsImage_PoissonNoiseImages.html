
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>cbOpticsImage_PoissonNoiseImages</title><meta name="generator" content="MATLAB 8.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2015-08-05"><meta name="DC.source" content="cbOpticsImage_PoissonNoiseImages.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">Function implementing the isetbio validation code</a></li><li><a href="#4">Hello</a></li><li><a href="#5">Supress irritating warnings</a></li><li><a href="#7">Frozen noise, so that we can validate OK</a></li><li><a href="#8">Load a hyperspectral scene in ISETBIO format.</a></li><li><a href="#9">Parameters</a></li><li><a href="#10">The scene object has a view about what the illuminant is.</a></li><li><a href="#11">Make optical image</a></li><li><a href="#12">Figure out optical image cropping parameters</a></li><li><a href="#13">Look at scene and oi sRGB images</a></li><li><a href="#14">Get the retinal irradiance per pixel</a></li><li><a href="#15">Pick an integration time to get photons</a></li><li><a href="#16">Make image noise free at selected wavelength</a></li><li><a href="#17">Make images for different irradiance levels</a></li><li><a href="#18">Make some explanatory figures that illustrate properties of the Poisson distribution.</a></li><li><a href="#19">Second explanatory figure plots Poisson SD as function of mean</a></li><li><a href="#20">Save validation data</a></li><li><a href="#21">Restore warning state</a></li><li><a href="#23">Restore warning state</a></li><li><a href="#24">Rethrow error</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> varargout = cbOpticsImage_PoissonNoiseImages(varargin)
<span class="comment">%</span>
<span class="comment">% Illustrate magnitude of Poisson noise as a function of light level.</span>
<span class="comment">%</span>
<span class="comment">% Produces images that show Poisson noise as a function of illuminant</span>
<span class="comment">% irradiance.  Also produces some explanatory figures about the Poisson</span>
<span class="comment">% distribution.</span>
<span class="comment">%</span>
<span class="comment">% (c) David Brainard and Andrew Stockman, 2015</span>

varargout = UnitTest.runValidationRun(@ValidationFunction, nargout, varargin);
<span class="keyword">end</span>
</pre><h2>Function implementing the isetbio validation code<a name="2"></a></h2><pre class="codeinput"><span class="keyword">function</span> ValidationFunction(runTimeParams)
</pre><h2>Hello<a name="4"></a></h2><pre class="codeinput">clear <span class="string">global</span>; ieInit;
UnitTest.validationRecord(<span class="string">'SIMPLE_MESSAGE'</span>, sprintf(<span class="string">'%s'</span>,mfilename));
outputDir = sprintf(<span class="string">'%s_Output'</span>,mfilename);
<span class="keyword">if</span> (~exist(outputDir,<span class="string">'dir'</span>))
    mkdir(outputDir);
<span class="keyword">end</span>
</pre><h2>Supress irritating warnings<a name="5"></a></h2><pre class="codeinput">warnS = warning(<span class="string">'off'</span>,<span class="string">'images:initSize:adjustingMag'</span>);
<span class="keyword">try</span>
</pre><h2>Frozen noise, so that we can validate OK<a name="7"></a></h2><pre class="codeinput">    randomSeedValue = 26;
    rng(randomSeedValue);
</pre><h2>Load a hyperspectral scene in ISETBIO format.<a name="8"></a></h2><p>A set of such images is produced as part of the BLHyperspectralImageComputations project.  You will need to get that project and generate the images for this script to run.</p><pre class="codeinput">    theHyperSceneDir = <span class="string">'/Volumes/Users1/Shared/Matlab/Analysis/hyperspectral-images/manchester_database'</span>;
    theHyperSceneName = <span class="string">'isetbioSceneFor_scene7.mat'</span>;
    <span class="keyword">if</span> (~exist(theHyperSceneDir,<span class="string">'dir'</span>))
        fprintf(<span class="string">'You need to get the hyperspectral image data to run this script.\n'</span>);
        <span class="keyword">return</span>;
    <span class="keyword">end</span>
    theData = load(fullfile(theHyperSceneDir,theHyperSceneName));
    theData.sceneRGBImage = sceneGet(theData.scene,<span class="string">'rgb image'</span>);
    <span class="comment">% vcAddAndSelectObject(theData.scene); sceneWindow;</span>
</pre><h2>Parameters<a name="9"></a></h2><pre class="codeinput">    theData.whichWavelength = 550;
    meanScalar = 0.2;
    displayGamma = 0.5;
    theIrradianceScaleFactors = [1e-3 1e-2 1e-1 1];
</pre><h2>The scene object has a view about what the illuminant is.<a name="10"></a></h2><p>Get this to help us set a reasonable physical scale for the scene.</p><pre class="codeinput">    sceneWave = sceneGet(theData.scene,<span class="string">'wave'</span>);
    sceneWlIndex = find(sceneWave == theData.whichWavelength);
    sceneS = WlsToS(sceneWave);
    theData.sceneIlluminantSpdRadiance_WattsPerM2SrNm = sceneGet(theData.scene,<span class="string">'illuminant energy'</span>);
    theData.sceneIlluminantSpdRadiance_QuantaPerSecM2SrNm = sceneGet(theData.scene,<span class="string">'illuminant photons'</span>);
    sceneIlluminantXYZ = sceneGet(theData.scene,<span class="string">'illuminant XYZ'</span>);
    load <span class="string">T_xyz1931</span>;
    T_xyz = SplineCmf(S_xyz1931,T_xyz1931,sceneS);
    ourSceneIlluminantXYZ = 683*T_xyz*theData.sceneIlluminantSpdRadiance_WattsPerM2SrNm*sceneS(2);
    theData.sceneIlluminantTotalIrradiance_WattsPerM2 = 2*pi*sum(theData.sceneIlluminantSpdRadiance_WattsPerM2SrNm*sceneS(2));
    theData.sceneIlluminantTotalIrradiance_QuantaPerSecM2 = 2*pi*sum(theData.sceneIlluminantSpdRadiance_QuantaPerSecM2SrNm*sceneS(2));

    <span class="comment">% Plot the illuminant spectrum</span>
    <span class="keyword">if</span> (runTimeParams.generatePlots)

        [illumSpdFig,figParams] = cbFigInit;
        figParams.xLimLow = 350;
        figParams.xLimHigh = 750;
        figParams.xTicks = [350 400 450 500 550 600 650 700 750];
        figParams.xTickLabels = {<span class="string">'^{ }350_{ }'</span> <span class="string">'^{ }400_{ }'</span> <span class="string">'^{ }450_{ }'</span> <span class="string">'^{ }500_{ }'</span> <span class="keyword">...</span>
        <span class="string">'^{ }550_{ }'</span> <span class="string">'^{ }600_{ }'</span> <span class="string">'^{ }650_{ }'</span> <span class="string">'^{ }700_{ }'</span> <span class="string">'^{ }750_{ }'</span>};
        figParams.yLimLow = 0;
        figParams.yLimHigh = 2e19;
        figParams.yTicks = [0 0.5e19 1.0e19 1.5e19 2.0e19];
        figParams.yTickLabels = {<span class="string">'  0.0 '</span> <span class="string">' 0.5 '</span> <span class="string">' 1.0 '</span> <span class="string">' 1.5 '</span> <span class="string">' 2.0 '</span>};

        plot(sceneWave,2*pi*theData.sceneIlluminantSpdRadiance_QuantaPerSecM2SrNm,<span class="string">'r'</span>,<span class="string">'LineWidth'</span>,figParams.lineWidth);

        xlabel(<span class="string">'Wavelength (nm)'</span>,<span class="string">'FontSize'</span>,figParams.labelFontSize);
        ylabel(<span class="string">'Irradiance (quanta/[sec-m^{2}-nm])'</span>,<span class="string">'FontSize'</span>,figParams.labelFontSize);
        title(<span class="string">'Scene Illuminant SPD'</span>,<span class="string">'FontSize'</span>,figParams.titleFontSize);
        cbFigAxisSet(illumSpdFig,figParams);
        text(345,2.075e19,<span class="string">'\times10^{19}'</span>,<span class="string">'FontName'</span>,figParams.fontName,<span class="string">'FontSize'</span>,figParams.axisFontSize);

        FigureSave(fullfile(outputDir,[mfilename <span class="string">'_IlluminantQuantalUnits'</span>]),illumSpdFig,figParams.figType);
    <span class="keyword">end</span>

    <span class="comment">% Print out some information.</span>
    UnitTest.assertIsZero(max(abs(sceneIlluminantXYZ(:)-ourSceneIlluminantXYZ(:))),<span class="string">'Check on XYZ computation'</span>,0.1);
    sceneFov = sceneGet(theData.scene,<span class="string">'horizontal fov'</span>);
    fprintf(<span class="string">'Scene field of view (horizontal) is %0.1f degrees\n'</span>,sceneFov);
    fprintf(<span class="string">'Scene illumination luminance taken as %0.0f cd/m2\n'</span>,sceneIlluminantXYZ(2));
    fprintf(<span class="string">'Scene illuminant irradiance at selected wavelength (%d nm) is %0.2g quanta/[sec-m2-nm]\n'</span>, <span class="keyword">...</span>
        theData.whichWavelength,2*pi*theData.sceneIlluminantSpdRadiance_QuantaPerSecM2SrNm(sceneWlIndex));
    fprintf(<span class="string">'Scene illuminant total irradiance %0.2g Watts/m2, %0.2g quanta/[sec-m2]\n'</span>,<span class="keyword">...</span>
        theData.sceneIlluminantTotalIrradiance_WattsPerM2,theData.sceneIlluminantTotalIrradiance_QuantaPerSecM2);
</pre><pre class="codeoutput">Scene field of view (horizontal) is 5.6 degrees
Scene illumination luminance taken as 58126 cd/m2
Scene illuminant irradiance at selected wavelength (550 nm) is 1.4e+19 quanta/[sec-m2-nm]
Scene illuminant total irradiance 1.5e+03 Watts/m2, 4.3e+21 quanta/[sec-m2]
</pre><img vspace="5" hspace="5" src="cbOpticsImage_PoissonNoiseImages_01.png" alt=""> <h2>Make optical image<a name="11"></a></h2><p>We do this to get retinal irradiance, and for the first part of this script we only want photon noise so we skip the blurring.  THere are built in ways to skip the blurring, but they have side effects that currently surprise me.  So we just set an OTF off all ones and get on with life.</p><pre class="codeinput">    theData.oi = oiCreate(<span class="string">'human'</span>);
    theData.optics = oiGet(theData.oi,<span class="string">'optics'</span>);
    theData.optics = opticsSet(theData.optics,<span class="string">'off axis method'</span>,<span class="string">'skip'</span>);
    OTFData = opticsGet(theData.optics,<span class="string">'otfdata'</span>);
    OTFDeltaData = ones(size(OTFData));
    theData.optics = opticsSet(theData.optics,<span class="string">'otfdata'</span>,OTFDeltaData);
    theData.oi = oiSet(theData.oi,<span class="string">'optics'</span>,theData.optics);
    theData.oi = oiCompute(theData.oi,theData.scene);
    theData.oiRGBImage = oiGet(theData.oi,<span class="string">'rgb image'</span>);
    <span class="comment">% vcAddAndSelectObject(theData.oi); oiWindow;</span>
</pre><h2>Figure out optical image cropping parameters<a name="12"></a></h2><p>The optical image gets padded to allow the OTF convolutions to have something to look at outside the border of the original image.  Figure out here how big this padding is so that we can crop the optical images back to the size of the original scene, give or take a pixel.</p><pre class="codeinput">    [sceneRows,sceneCols] = size(theData.sceneRGBImage(:,:,1));
    [oiRows,oiCols] = size(theData.oiRGBImage(:,:,1));
    extraRows = oiRows - sceneRows;
    extraCols = oiCols - sceneCols;
    cropRows = ceil(extraRows/2):oiRows-ceil(extraRows/2)-1;
    cropCols = ceil(extraCols/2):oiCols-ceil(extraCols/2)-1;
</pre><h2>Look at scene and oi sRGB images<a name="13"></a></h2><p>Because these are normalized and we didn't blur, they look the same.</p><pre class="codeinput">    <span class="keyword">if</span> (runTimeParams.generatePlots)
        figure; clf;
        imshow(theData.sceneRGBImage);
        set(gcf,<span class="string">'Name'</span>,<span class="string">'Scene Radiance sRGB'</span>);
        imwrite(theData.sceneRGBImage,fullfile(outputDir,[mfilename <span class="string">'_SceneRadianceRGB.png'</span>]),<span class="string">'png'</span>);

        figure; clf;
        imshow(theData.oiRGBImage(cropRows,cropCols,:));
        set(gcf,<span class="string">'Name'</span>,<span class="string">'Retinal Image sRGB'</span>);
        imwrite(theData.oiRGBImage(cropRows,cropCols,:),fullfile(outputDir,[mfilename <span class="string">'_RetinalIrradianceRGB.png'</span>]),<span class="string">'png'</span>);
    <span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="cbOpticsImage_PoissonNoiseImages_02.png" alt=""> <img vspace="5" hspace="5" src="cbOpticsImage_PoissonNoiseImages_03.png" alt=""> <h2>Get the retinal irradiance per pixel<a name="14"></a></h2><pre class="codeinput">    oiWave = oiGet(theData.oi,<span class="string">'wave'</span>);
    oiWlIndex = find(oiWave == theData.whichWavelength);
    theData.oiIrradiance_PhotonsPerSecM2Nm = double(oiGet(theData.oi,<span class="string">'photons'</span>));
    oiPixelSize_M = oiGet(theData.oi,<span class="string">'sample spacing'</span>);
    oiPixelArea_M2 = oiPixelSize_M(1)*oiPixelSize_M(2);
    oiIrradiance_PhotonsPerSecPixel = theData.oiIrradiance_PhotonsPerSecM2Nm*oiPixelArea_M2;
    oiFov = oiGet(theData.oi,<span class="string">'fov'</span>);
    fprintf(<span class="string">'Optical image field of view (horizontal) is %0.1f degrees\n'</span>,oiFov);
    fprintf(<span class="string">'Pixel size is %0.2f by %0.2f um\n'</span>,oiPixelSize_M(1)*1e6,oiPixelSize_M(2)*1e6);
    fprintf(<span class="string">'Pixel area is %0.2f um\n'</span>,oiPixelArea_M2*1e12);

    <span class="comment">% Print mean/maximum irradiance, as a check</span>
    temp = theData.oiIrradiance_PhotonsPerSecM2Nm(cropRows,cropCols,:);
    meanIrradiance_PhotonsPOerSecM2 = mean(temp(:));
    maxIrradiance_PhotonsPOerSecM2 = max(temp(:));

    temp = theData.oiIrradiance_PhotonsPerSecM2Nm(cropRows,cropCols,oiWlIndex);
    selectedWavelengthIrradiance_PhotonsPerSecM2 = mean(temp(:));
    fprintf(<span class="string">'Mean retinal illuminance at selected wavelength (%d nm) is %0.2g quanta/[sec-m2]\n'</span>,theData.whichWavelength,selectedWavelengthIrradiance_PhotonsPerSecM2);
    fprintf(<span class="string">'Mean optical image irradiance is %0.2g quanta/[sec-m2-nm]; max is %0.2g\n'</span>,meanIrradiance_PhotonsPOerSecM2,maxIrradiance_PhotonsPOerSecM2);
</pre><pre class="codeoutput">Optical image field of view (horizontal) is 6.9 degrees
Pixel size is 1.24 by 1.24 um
Pixel area is 1.53 um
Mean retinal illuminance at selected wavelength (550 nm) is 1.6e+15 quanta/[sec-m2]
Mean optical image irradiance is 1.6e+15 quanta/[sec-m2-nm]; max is 1.2e+16
</pre><h2>Pick an integration time to get photons<a name="15"></a></h2><pre class="codeinput">    theData.integrationTime_Sec = 0.050;
    oiEnergy_PhotonsPerPixel = oiIrradiance_PhotonsPerSecPixel*theData.integrationTime_Sec;
</pre><h2>Make image noise free at selected wavelength<a name="16"></a></h2><pre class="codeinput">    meanPhotons0 = double(oiEnergy_PhotonsPerPixel(:,:,oiWlIndex));
    scaledMeanPhotons0 = meanScalar*meanPhotons0/mean(meanPhotons0(:));
    <span class="keyword">if</span> (runTimeParams.generatePlots)
        figure; clf;
        imshow(scaledMeanPhotons0(cropRows,cropCols,:).^displayGamma);
        set(gcf,<span class="string">'Name'</span>,<span class="string">'No noise'</span>);
        imwrite(scaledMeanPhotons0(cropRows,cropCols,:).^displayGamma,<span class="keyword">...</span>
            fullfile(outputDir,[mfilename <span class="string">'_NoNoiseImageAtWavelength.png'</span>]),<span class="string">'png'</span>);
    <span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="cbOpticsImage_PoissonNoiseImages_04.png" alt=""> <h2>Make images for different irradiance levels<a name="17"></a></h2><pre class="codeinput">    <span class="keyword">if</span> (runTimeParams.generatePlots)
        noiseFigure = figure; clf;
        set(gcf,<span class="string">'Position'</span>,[81 114 1100 1100]);
    <span class="keyword">end</span>
    <span class="keyword">for</span> ii = 1:length(theIrradianceScaleFactors)
        <span class="comment">% Get mean number of photons at each pixel at the desired wavelength</span>
        <span class="comment">% and irradiance scale factor</span>
        meanPhotons = theIrradianceScaleFactors(ii)*double(oiEnergy_PhotonsPerPixel(:,:,oiWlIndex));

        <span class="comment">% Get a draw of Poisson noise around the mean</span>
        noisyPhotons = poissrnd(meanPhotons);

        <span class="comment">% Scale in a consistent manner for display</span>
        scaledNoisyPhotons = meanScalar*noisyPhotons/mean(meanPhotons(:));

        <span class="comment">% Make a figure</span>
        <span class="keyword">if</span> (runTimeParams.generatePlots)
            figure(noiseFigure);
            subplot_tight(2,2,ii,0.02);
            imshow(scaledNoisyPhotons(cropRows,cropCols,:).^displayGamma);
            title(sprintf(<span class="string">'%0.2g quanta/sec-m^{2}'</span>,theIrradianceScaleFactors(ii)*2*pi*theData.sceneIlluminantSpdRadiance_QuantaPerSecM2SrNm(sceneWlIndex)), <span class="keyword">...</span>
                <span class="string">'FontName'</span>,figParams.fontName,<span class="string">'FontSize'</span>,figParams.titleFontSize-2);
        <span class="keyword">end</span>

        <span class="comment">% Check.  Isetbio can give us a photon noise image, so when the scale</span>
        <span class="comment">% factor is unity we generate that too and have a look.  That returns</span>
        <span class="comment">% the value for a 50 msec integration time and one pixel.</span>
        CHECK = false;
        <span class="keyword">if</span> (CHECK &amp; theIrradianceScaleFactors(ii) == 1 &amp; theData.integrationTime_Sec == 0.050)
            <span class="comment">% Let oiGet do its thing</span>
            noisyPhotonsISETBIO = oiGet(theData.oi,<span class="string">'photons noise'</span>);
            noisyPhotonsISETBIO = double(noisyPhotonsISETBIO(:,:,oiWlIndex));

            <span class="comment">% Scale</span>
            scaledNoisyPhotonsISETBIO = meanScalar*noisyPhotonsISETBIO/mean(meanPhotons(:));

            <span class="comment">% Make a figure</span>
            <span class="keyword">if</span> (runTimeParams.generatePlots)
                figure; clf;
                imshow(scaledNoisyPhotonsISETBIO(cropRows,cropCols,:).^displayGamma);
                set(gcf,<span class="string">'Name'</span>,<span class="string">'ISETBIO noisy photons return'</span>);
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">% Save the figure of the images</span>
    <span class="keyword">if</span> (runTimeParams.generatePlots)
        figure(noiseFigure);

        <span class="comment">% Try to add a title to the subplot montage, but it isn't working</span>
        <span class="comment">% for me easily.  Not sure why, as suplabel has worked for me in</span>
        <span class="comment">% other situations.</span>
        <span class="comment">% [~,h] = suplabel('Poisson Photon Noise','t');</span>
        <span class="comment">% set(h,'FontName',figParams.fontName,'FontSize',figParams.titleFontSize);</span>

        <span class="comment">% Save the PDF</span>
        FigureSave(fullfile(outputDir,[mfilename <span class="string">'_NoiseImageFigure'</span>]),noiseFigure,<span class="string">'png'</span>);
    <span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="cbOpticsImage_PoissonNoiseImages_05.png" alt=""> <h2>Make some explanatory figures that illustrate properties of the Poisson distribution.<a name="18"></a></h2><p>First figure just shows Poisson PDF for two different means, to give the general idea.</p><pre class="codeinput">    data.mean1 = 10;
    data.mean2 = 100;
    data.xValues = 0:2*data.mean2;
    data.probMean1 = poisspdf(data.xValues,data.mean1);
    data.probMean2 = poisspdf(data.xValues,data.mean2);
    <span class="keyword">if</span> (runTimeParams.generatePlots)
        [poissPDFFig,figParams] = cbFigInit;
        figParams.xLimLow = 0;
        figParams.xLimHigh = 150;
        figParams.xTicks = [0 50 100 150];
        figParams.xTickLabels = {<span class="string">'^{ }0_{ }'</span> <span class="string">'^{ }50_{ }'</span> <span class="string">'^{ }100_{ }'</span> <span class="string">'^{ }150_{ }'</span>};
        figParams.yLimLow = 0;
        figParams.yLimHigh = 0.15;
        figParams.yTicks = [0 .05 .10 .15];
        figParams.yTickLabels = {<span class="string">'  0.00 '</span> <span class="string">'  0.05 '</span> <span class="string">' 0.10 '</span> <span class="string">' 0.15 '</span>};

        plot(data.xValues,data.probMean1,<span class="string">'r'</span>,<span class="string">'LineWidth'</span>,figParams.lineWidth);
        plot(data.xValues,data.probMean2,<span class="string">'b'</span>,<span class="string">'LineWidth'</span>,figParams.lineWidth);

        xlabel(<span class="string">'Quanta'</span>,<span class="string">'FontSize'</span>,figParams.labelFontSize);
        ylabel(<span class="string">'Pr(q)'</span>,<span class="string">'FontSize'</span>,figParams.labelFontSize);
        title(<span class="string">'Poisson PDF'</span>,<span class="string">'FontSize'</span>,figParams.titleFontSize);
        cbFigAxisSet(poissPDFFig,figParams);

        <span class="comment">% Legend, with tweak to make lines long enough so that dash shows.</span>
        <span class="comment">% Note the extra spaces that preface the actual legend text. Ugh.</span>
        [~,legendChildObjs] = legend({[<span class="string">'^{ }'</span> figParams.legendExtraSpaceStr <span class="string">'  Mean '</span> num2str(data.mean1) <span class="string">' '</span>],[ <span class="string">'^{ }'</span> figParams.legendExtraSpaceStr <span class="string">'  Mean '</span> num2str(data.mean2) <span class="string">' '</span>]},<span class="keyword">...</span>
            <span class="string">'Location'</span>,<span class="string">'NorthEast'</span>,<span class="string">'FontSize'</span>,figParams.legendFontSize);
        lineObjs = findobj(legendChildObjs, <span class="string">'Type'</span>, <span class="string">'line'</span>);
        xCoords = get(lineObjs, <span class="string">'XData'</span>) ;
        <span class="keyword">for</span> lineIdx = 1:length(xCoords)
            <span class="keyword">if</span> (length(xCoords{lineIdx}) ~= 2), <span class="keyword">continue</span>; <span class="keyword">end</span>
            set(lineObjs(lineIdx), <span class="string">'XData'</span>, xCoords{lineIdx} + [0 figParams.legendLineTweak])
        <span class="keyword">end</span>

        <span class="comment">% Save the plot</span>
        FigureSave(fullfile(outputDir,[mfilename <span class="string">'_PoissonPDF'</span>]),poissPDFFig,figParams.figType);
    <span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="cbOpticsImage_PoissonNoiseImages_06.png" alt=""> <h2>Second explanatory figure plots Poisson SD as function of mean<a name="19"></a></h2><p>This is a measure of how big a signal has to be against a background to be an equivalent amount above the noise.  OK, so it is a simple plot.  But I stil like it.</p><pre class="codeinput">    data.decades = 6;
    data.theMeans = logspace(0,data.decades,1000);
    data.theSDs = sqrt(data.theMeans);
    <span class="keyword">if</span> (runTimeParams.generatePlots)
        [poissSDMeanRatio,figParams] = cbFigInit;
        figParams.xLimLow = 10^0;
        figParams.xLimHigh = 10^6;
        figParams.xTicks = [10^0 10^1 10^2 10^3 10^4 10^5 10^6];
        figParams.xTickLabels = {<span class="string">'^{ }10^{0}_{ }'</span> <span class="string">'^{ }10^{1}_{ }'</span> <span class="string">'^{ }10^{2}_{ }'</span> <span class="string">'^{ }10^{3}_{ }'</span> <span class="string">'^{ }10^{4}_{ }'</span> <span class="string">'^{ }10^{5}_{ }'</span> <span class="string">'^{ }10^{6}_{ }'</span>};
        figParams.yLimLow = 0;
        figParams.yLimHigh = 1000;
        figParams.yTicks = [0 200 400 600 800 1000];
        figParams.yTickLabels = {<span class="string">'    0 '</span> <span class="string">'   200 '</span> <span class="string">'  400 '</span> <span class="string">'  600 '</span> <span class="string">'  800 '</span> <span class="string">' 1000 '</span>};

        <span class="comment">% For semilog, need hold off for first plot, otherwise don't get</span>
        <span class="comment">% seimilog axis.  Go figure.</span>
        hold <span class="string">off</span>;
        semilogx(data.theMeans,data.theSDs,<span class="string">'r'</span>,<span class="string">'LineWidth'</span>,figParams.lineWidth);
        hold <span class="string">on</span>;

        xlabel(<span class="string">'Background Quanta'</span>,<span class="string">'FontSize'</span>,figParams.labelFontSize);
        ylabel(<span class="string">'Standard Deviation (quanta)'</span>,<span class="string">'FontSize'</span>,figParams.labelFontSize);
        title(<span class="string">'Poisson Noise Limits'</span>,<span class="string">'FontSize'</span>,figParams.titleFontSize);
        cbFigAxisSet(poissSDMeanRatio,figParams);

        <span class="comment">% Save the plot</span>
        FigureSave(fullfile(outputDir,[mfilename <span class="string">'_PoissonMeanSDRatio'</span>]),poissSDMeanRatio,figParams.figType);
    <span class="keyword">end</span>

    <span class="comment">% Can slso look at how the standard deviation over the mean grows,</span>
    <span class="comment">% which is how threshold would vary when expressed as contrast.</span>
    <span class="keyword">if</span> (runTimeParams.generatePlots)
        [poissSDMeanContrastRatio,figParams] = cbFigInit;
        figParams.xLimLow = 10^0;
        figParams.xLimHigh = 10^6;
        figParams.xTicks = [10^0 10^1 10^2 10^3 10^4 10^5 10^6];
        figParams.xTickLabels = {<span class="string">'^{ }10^{0}_{ }'</span> <span class="string">'^{ }10^{1}_{ }'</span> <span class="string">'^{ }10^{2}_{ }'</span> <span class="string">'^{ }10^{3}_{ }'</span> <span class="string">'^{ }10^{4}_{ }'</span> <span class="string">'^{ }10^{5}_{ }'</span> <span class="string">'^{ }10^{6}_{ }'</span>};
        figParams.yLimLow = 0;
        figParams.yLimHigh = 1;
        figParams.yTicks = [0 0.2 0.4 0.6 0.8 1];
        figParams.yTickLabels = {<span class="string">' 0.0 '</span> <span class="string">'  0.2 '</span> <span class="string">'  0.4 '</span> <span class="string">'  0.6 '</span> <span class="string">'  0.8 '</span> <span class="string">'  1.0 '</span>};

        <span class="comment">% For semilog, need hold off for first plot, otherwise don't get</span>
        <span class="comment">% seimilog axis.  Go figure.</span>
        hold <span class="string">off</span>;
        semilogx(data.theMeans,data.theSDs./data.theMeans,<span class="string">'r'</span>,<span class="string">'LineWidth'</span>,figParams.lineWidth);
        hold <span class="string">on</span>;

        xlabel(<span class="string">'Background Quanta'</span>,<span class="string">'FontSize'</span>,figParams.labelFontSize);
        ylabel(<span class="string">'Standard Deviation (contrast)'</span>,<span class="string">'FontSize'</span>,figParams.labelFontSize);
        title(<span class="string">'Poisson Noise Limits'</span>,<span class="string">'FontSize'</span>,figParams.titleFontSize);
        cbFigAxisSet(poissSDMeanContrastRatio,figParams);

        <span class="comment">% Save the plot</span>
        FigureSave(fullfile(outputDir,[mfilename <span class="string">'_PoissonMeanSDContrastRatio'</span>]),poissSDMeanContrastRatio,figParams.figType);
    <span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="cbOpticsImage_PoissonNoiseImages_07.png" alt=""> <img vspace="5" hspace="5" src="cbOpticsImage_PoissonNoiseImages_08.png" alt=""> <h2>Save validation data<a name="20"></a></h2><p>Strip out some of the really big stuff.</p><pre class="codeinput">    theData = rmfield(theData,<span class="string">'scene'</span>);
    theData = rmfield(theData,<span class="string">'oi'</span>);
    theData.partialIrradiance = theData.oiIrradiance_PhotonsPerSecM2Nm(1:10,100:110,8);
    theData = rmfield(theData,<span class="string">'oiIrradiance_PhotonsPerSecM2Nm'</span>);
    UnitTest.validationData(<span class="string">'theData'</span>, theData);
</pre><h2>Restore warning state<a name="21"></a></h2><pre class="codeinput">    warning(warnS.state,warnS.identifier);
</pre><pre class="codeinput"><span class="keyword">catch</span> err
</pre><h2>Restore warning state<a name="23"></a></h2><pre class="codeinput">    warning(warnS.state,warnS.identifier);
</pre><h2>Rethrow error<a name="24"></a></h2><pre class="codeinput">    rethrow(err);
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2014b</a><br></p></div><!--
##### SOURCE BEGIN #####
function varargout = cbOpticsImage_PoissonNoiseImages(varargin)
%
% Illustrate magnitude of Poisson noise as a function of light level.
%
% Produces images that show Poisson noise as a function of illuminant
% irradiance.  Also produces some explanatory figures about the Poisson
% distribution.
%
% (c) David Brainard and Andrew Stockman, 2015

varargout = UnitTest.runValidationRun(@ValidationFunction, nargout, varargin);
end

%% Function implementing the isetbio validation code
function ValidationFunction(runTimeParams)

%% Hello
clear global; ieInit;
UnitTest.validationRecord('SIMPLE_MESSAGE', sprintf('%s',mfilename));
outputDir = sprintf('%s_Output',mfilename);
if (~exist(outputDir,'dir'))
    mkdir(outputDir);
end

%% Supress irritating warnings
warnS = warning('off','images:initSize:adjustingMag');
try
    
    %% Frozen noise, so that we can validate OK
    randomSeedValue = 26;
    rng(randomSeedValue);

    %% Load a hyperspectral scene in ISETBIO format.
    %
    % A set of such images is produced as part of the
    % BLHyperspectralImageComputations project.  You will need
    % to get that project and generate the images for this script to run.
    theHyperSceneDir = '/Volumes/Users1/Shared/Matlab/Analysis/hyperspectral-images/manchester_database';
    theHyperSceneName = 'isetbioSceneFor_scene7.mat';
    if (~exist(theHyperSceneDir,'dir'))
        fprintf('You need to get the hyperspectral image data to run this script.\n');
        return;
    end
    theData = load(fullfile(theHyperSceneDir,theHyperSceneName));
    theData.sceneRGBImage = sceneGet(theData.scene,'rgb image');
    % vcAddAndSelectObject(theData.scene); sceneWindow;

    %% Parameters
    theData.whichWavelength = 550;
    meanScalar = 0.2;
    displayGamma = 0.5;
    theIrradianceScaleFactors = [1e-3 1e-2 1e-1 1];
    
    %% The scene object has a view about what the illuminant is.
    %
    % Get this to help us set a reasonable physical scale for the scene.
    sceneWave = sceneGet(theData.scene,'wave');
    sceneWlIndex = find(sceneWave == theData.whichWavelength);
    sceneS = WlsToS(sceneWave);
    theData.sceneIlluminantSpdRadiance_WattsPerM2SrNm = sceneGet(theData.scene,'illuminant energy');
    theData.sceneIlluminantSpdRadiance_QuantaPerSecM2SrNm = sceneGet(theData.scene,'illuminant photons');
    sceneIlluminantXYZ = sceneGet(theData.scene,'illuminant XYZ');
    load T_xyz1931;
    T_xyz = SplineCmf(S_xyz1931,T_xyz1931,sceneS);
    ourSceneIlluminantXYZ = 683*T_xyz*theData.sceneIlluminantSpdRadiance_WattsPerM2SrNm*sceneS(2);
    theData.sceneIlluminantTotalIrradiance_WattsPerM2 = 2*pi*sum(theData.sceneIlluminantSpdRadiance_WattsPerM2SrNm*sceneS(2));
    theData.sceneIlluminantTotalIrradiance_QuantaPerSecM2 = 2*pi*sum(theData.sceneIlluminantSpdRadiance_QuantaPerSecM2SrNm*sceneS(2));
    
    % Plot the illuminant spectrum
    if (runTimeParams.generatePlots)
        
        [illumSpdFig,figParams] = cbFigInit;
        figParams.xLimLow = 350;
        figParams.xLimHigh = 750;
        figParams.xTicks = [350 400 450 500 550 600 650 700 750];
        figParams.xTickLabels = {'^{ }350_{ }' '^{ }400_{ }' '^{ }450_{ }' '^{ }500_{ }' ...
        '^{ }550_{ }' '^{ }600_{ }' '^{ }650_{ }' '^{ }700_{ }' '^{ }750_{ }'};
        figParams.yLimLow = 0;
        figParams.yLimHigh = 2e19;
        figParams.yTicks = [0 0.5e19 1.0e19 1.5e19 2.0e19];
        figParams.yTickLabels = {'  0.0 ' ' 0.5 ' ' 1.0 ' ' 1.5 ' ' 2.0 '};
        
        plot(sceneWave,2*pi*theData.sceneIlluminantSpdRadiance_QuantaPerSecM2SrNm,'r','LineWidth',figParams.lineWidth);
        
        xlabel('Wavelength (nm)','FontSize',figParams.labelFontSize);
        ylabel('Irradiance (quanta/[sec-m^{2}-nm])','FontSize',figParams.labelFontSize);
        title('Scene Illuminant SPD','FontSize',figParams.titleFontSize);
        cbFigAxisSet(illumSpdFig,figParams);
        text(345,2.075e19,'\times10^{19}','FontName',figParams.fontName,'FontSize',figParams.axisFontSize);
        
        FigureSave(fullfile(outputDir,[mfilename '_IlluminantQuantalUnits']),illumSpdFig,figParams.figType);
    end
    
    % Print out some information.
    UnitTest.assertIsZero(max(abs(sceneIlluminantXYZ(:)-ourSceneIlluminantXYZ(:))),'Check on XYZ computation',0.1);
    sceneFov = sceneGet(theData.scene,'horizontal fov');
    fprintf('Scene field of view (horizontal) is %0.1f degrees\n',sceneFov);
    fprintf('Scene illumination luminance taken as %0.0f cd/m2\n',sceneIlluminantXYZ(2));
    fprintf('Scene illuminant irradiance at selected wavelength (%d nm) is %0.2g quanta/[sec-m2-nm]\n', ...
        theData.whichWavelength,2*pi*theData.sceneIlluminantSpdRadiance_QuantaPerSecM2SrNm(sceneWlIndex));
    fprintf('Scene illuminant total irradiance %0.2g Watts/m2, %0.2g quanta/[sec-m2]\n',...
        theData.sceneIlluminantTotalIrradiance_WattsPerM2,theData.sceneIlluminantTotalIrradiance_QuantaPerSecM2);
    
    %% Make optical image
    %
    % We do this to get retinal irradiance, and for the first part of this
    % script we only want photon noise so we skip the blurring.  THere are
    % built in ways to skip the blurring, but they have side effects that
    % currently surprise me.  So we just set an OTF off all ones and get
    % on with life.
    theData.oi = oiCreate('human');
    theData.optics = oiGet(theData.oi,'optics');
    theData.optics = opticsSet(theData.optics,'off axis method','skip');
    OTFData = opticsGet(theData.optics,'otfdata');
    OTFDeltaData = ones(size(OTFData));
    theData.optics = opticsSet(theData.optics,'otfdata',OTFDeltaData);
    theData.oi = oiSet(theData.oi,'optics',theData.optics);
    theData.oi = oiCompute(theData.oi,theData.scene);
    theData.oiRGBImage = oiGet(theData.oi,'rgb image');
    % vcAddAndSelectObject(theData.oi); oiWindow;
    
    %% Figure out optical image cropping parameters
    %
    % The optical image gets padded to allow the OTF 
    % convolutions to have something to look at outside
    % the border of the original image.  Figure out here
    % how big this padding is so that we can crop the optical
    % images back to the size of the original scene, give or
    % take a pixel.
    [sceneRows,sceneCols] = size(theData.sceneRGBImage(:,:,1));
    [oiRows,oiCols] = size(theData.oiRGBImage(:,:,1));
    extraRows = oiRows - sceneRows;
    extraCols = oiCols - sceneCols;
    cropRows = ceil(extraRows/2):oiRows-ceil(extraRows/2)-1;
    cropCols = ceil(extraCols/2):oiCols-ceil(extraCols/2)-1;
    
    %% Look at scene and oi sRGB images
    %
    % Because these are normalized and we didn't blur, they look the same.
    if (runTimeParams.generatePlots)
        figure; clf;
        imshow(theData.sceneRGBImage);
        set(gcf,'Name','Scene Radiance sRGB');
        imwrite(theData.sceneRGBImage,fullfile(outputDir,[mfilename '_SceneRadianceRGB.png']),'png');
        
        figure; clf;
        imshow(theData.oiRGBImage(cropRows,cropCols,:));
        set(gcf,'Name','Retinal Image sRGB');
        imwrite(theData.oiRGBImage(cropRows,cropCols,:),fullfile(outputDir,[mfilename '_RetinalIrradianceRGB.png']),'png');
    end
    
    %% Get the retinal irradiance per pixel
    oiWave = oiGet(theData.oi,'wave');
    oiWlIndex = find(oiWave == theData.whichWavelength);
    theData.oiIrradiance_PhotonsPerSecM2Nm = double(oiGet(theData.oi,'photons'));
    oiPixelSize_M = oiGet(theData.oi,'sample spacing');
    oiPixelArea_M2 = oiPixelSize_M(1)*oiPixelSize_M(2);
    oiIrradiance_PhotonsPerSecPixel = theData.oiIrradiance_PhotonsPerSecM2Nm*oiPixelArea_M2;
    oiFov = oiGet(theData.oi,'fov');
    fprintf('Optical image field of view (horizontal) is %0.1f degrees\n',oiFov);
    fprintf('Pixel size is %0.2f by %0.2f um\n',oiPixelSize_M(1)*1e6,oiPixelSize_M(2)*1e6);
    fprintf('Pixel area is %0.2f um\n',oiPixelArea_M2*1e12);
    
    % Print mean/maximum irradiance, as a check
    temp = theData.oiIrradiance_PhotonsPerSecM2Nm(cropRows,cropCols,:);
    meanIrradiance_PhotonsPOerSecM2 = mean(temp(:));
    maxIrradiance_PhotonsPOerSecM2 = max(temp(:));
    
    temp = theData.oiIrradiance_PhotonsPerSecM2Nm(cropRows,cropCols,oiWlIndex);
    selectedWavelengthIrradiance_PhotonsPerSecM2 = mean(temp(:));
    fprintf('Mean retinal illuminance at selected wavelength (%d nm) is %0.2g quanta/[sec-m2]\n',theData.whichWavelength,selectedWavelengthIrradiance_PhotonsPerSecM2);
    fprintf('Mean optical image irradiance is %0.2g quanta/[sec-m2-nm]; max is %0.2g\n',meanIrradiance_PhotonsPOerSecM2,maxIrradiance_PhotonsPOerSecM2);
    
    %% Pick an integration time to get photons
    theData.integrationTime_Sec = 0.050;
    oiEnergy_PhotonsPerPixel = oiIrradiance_PhotonsPerSecPixel*theData.integrationTime_Sec;
        
    %% Make image noise free at selected wavelength
    meanPhotons0 = double(oiEnergy_PhotonsPerPixel(:,:,oiWlIndex));
    scaledMeanPhotons0 = meanScalar*meanPhotons0/mean(meanPhotons0(:));
    if (runTimeParams.generatePlots)
        figure; clf;
        imshow(scaledMeanPhotons0(cropRows,cropCols,:).^displayGamma);
        set(gcf,'Name','No noise');
        imwrite(scaledMeanPhotons0(cropRows,cropCols,:).^displayGamma,...
            fullfile(outputDir,[mfilename '_NoNoiseImageAtWavelength.png']),'png');
    end
    
    %% Make images for different irradiance levels
    if (runTimeParams.generatePlots)
        noiseFigure = figure; clf;
        set(gcf,'Position',[81 114 1100 1100]);
    end
    for ii = 1:length(theIrradianceScaleFactors)
        % Get mean number of photons at each pixel at the desired wavelength
        % and irradiance scale factor
        meanPhotons = theIrradianceScaleFactors(ii)*double(oiEnergy_PhotonsPerPixel(:,:,oiWlIndex));
        
        % Get a draw of Poisson noise around the mean
        noisyPhotons = poissrnd(meanPhotons);
        
        % Scale in a consistent manner for display
        scaledNoisyPhotons = meanScalar*noisyPhotons/mean(meanPhotons(:));
        
        % Make a figure
        if (runTimeParams.generatePlots)
            figure(noiseFigure);
            subplot_tight(2,2,ii,0.02);
            imshow(scaledNoisyPhotons(cropRows,cropCols,:).^displayGamma);
            title(sprintf('%0.2g quanta/sec-m^{2}',theIrradianceScaleFactors(ii)*2*pi*theData.sceneIlluminantSpdRadiance_QuantaPerSecM2SrNm(sceneWlIndex)), ...
                'FontName',figParams.fontName,'FontSize',figParams.titleFontSize-2);
        end
        
        % Check.  Isetbio can give us a photon noise image, so when the scale
        % factor is unity we generate that too and have a look.  That returns
        % the value for a 50 msec integration time and one pixel.
        CHECK = false;
        if (CHECK & theIrradianceScaleFactors(ii) == 1 & theData.integrationTime_Sec == 0.050)
            % Let oiGet do its thing
            noisyPhotonsISETBIO = oiGet(theData.oi,'photons noise');
            noisyPhotonsISETBIO = double(noisyPhotonsISETBIO(:,:,oiWlIndex));
            
            % Scale
            scaledNoisyPhotonsISETBIO = meanScalar*noisyPhotonsISETBIO/mean(meanPhotons(:));
            
            % Make a figure
            if (runTimeParams.generatePlots)
                figure; clf;
                imshow(scaledNoisyPhotonsISETBIO(cropRows,cropCols,:).^displayGamma);
                set(gcf,'Name','ISETBIO noisy photons return');
            end
        end
    end
    
    % Save the figure of the images
    if (runTimeParams.generatePlots)
        figure(noiseFigure);
        
        % Try to add a title to the subplot montage, but it isn't working
        % for me easily.  Not sure why, as suplabel has worked for me in
        % other situations.
        % [~,h] = suplabel('Poisson Photon Noise','t');
        % set(h,'FontName',figParams.fontName,'FontSize',figParams.titleFontSize);
        
        % Save the PDF
        FigureSave(fullfile(outputDir,[mfilename '_NoiseImageFigure']),noiseFigure,'png');
    end
    
    %% Make some explanatory figures that illustrate properties of the Poisson distribution.
    %
    % First figure just shows Poisson PDF for two different means, to give
    % the general idea.
    data.mean1 = 10;
    data.mean2 = 100;
    data.xValues = 0:2*data.mean2;
    data.probMean1 = poisspdf(data.xValues,data.mean1);
    data.probMean2 = poisspdf(data.xValues,data.mean2);
    if (runTimeParams.generatePlots)
        [poissPDFFig,figParams] = cbFigInit;
        figParams.xLimLow = 0;
        figParams.xLimHigh = 150;
        figParams.xTicks = [0 50 100 150];
        figParams.xTickLabels = {'^{ }0_{ }' '^{ }50_{ }' '^{ }100_{ }' '^{ }150_{ }'};
        figParams.yLimLow = 0;
        figParams.yLimHigh = 0.15;
        figParams.yTicks = [0 .05 .10 .15];
        figParams.yTickLabels = {'  0.00 ' '  0.05 ' ' 0.10 ' ' 0.15 '};
        
        plot(data.xValues,data.probMean1,'r','LineWidth',figParams.lineWidth);
        plot(data.xValues,data.probMean2,'b','LineWidth',figParams.lineWidth);
        
        xlabel('Quanta','FontSize',figParams.labelFontSize);
        ylabel('Pr(q)','FontSize',figParams.labelFontSize);
        title('Poisson PDF','FontSize',figParams.titleFontSize);
        cbFigAxisSet(poissPDFFig,figParams);
        
        % Legend, with tweak to make lines long enough so that dash shows.
        % Note the extra spaces that preface the actual legend text. Ugh.
        [~,legendChildObjs] = legend({['^{ }' figParams.legendExtraSpaceStr '  Mean ' num2str(data.mean1) ' '],[ '^{ }' figParams.legendExtraSpaceStr '  Mean ' num2str(data.mean2) ' ']},...
            'Location','NorthEast','FontSize',figParams.legendFontSize);
        lineObjs = findobj(legendChildObjs, 'Type', 'line');
        xCoords = get(lineObjs, 'XData') ;
        for lineIdx = 1:length(xCoords)
            if (length(xCoords{lineIdx}) ~= 2), continue; end
            set(lineObjs(lineIdx), 'XData', xCoords{lineIdx} + [0 figParams.legendLineTweak])
        end
        
        % Save the plot
        FigureSave(fullfile(outputDir,[mfilename '_PoissonPDF']),poissPDFFig,figParams.figType); 
    end
    
    %% Second explanatory figure plots Poisson SD as function of mean
    % 
    % This is a measure of how big a signal has to be against a background
    % to be an equivalent amount above the noise.  OK, so it is a simple
    % plot.  But I stil like it.
    data.decades = 6;
    data.theMeans = logspace(0,data.decades,1000);
    data.theSDs = sqrt(data.theMeans);
    if (runTimeParams.generatePlots)
        [poissSDMeanRatio,figParams] = cbFigInit;
        figParams.xLimLow = 10^0;
        figParams.xLimHigh = 10^6;
        figParams.xTicks = [10^0 10^1 10^2 10^3 10^4 10^5 10^6];
        figParams.xTickLabels = {'^{ }10^{0}_{ }' '^{ }10^{1}_{ }' '^{ }10^{2}_{ }' '^{ }10^{3}_{ }' '^{ }10^{4}_{ }' '^{ }10^{5}_{ }' '^{ }10^{6}_{ }'};
        figParams.yLimLow = 0;
        figParams.yLimHigh = 1000;
        figParams.yTicks = [0 200 400 600 800 1000];
        figParams.yTickLabels = {'    0 ' '   200 ' '  400 ' '  600 ' '  800 ' ' 1000 '};
        
        % For semilog, need hold off for first plot, otherwise don't get
        % seimilog axis.  Go figure.
        hold off;
        semilogx(data.theMeans,data.theSDs,'r','LineWidth',figParams.lineWidth);
        hold on; 
        
        xlabel('Background Quanta','FontSize',figParams.labelFontSize);
        ylabel('Standard Deviation (quanta)','FontSize',figParams.labelFontSize);
        title('Poisson Noise Limits','FontSize',figParams.titleFontSize);
        cbFigAxisSet(poissSDMeanRatio,figParams);
        
        % Save the plot
        FigureSave(fullfile(outputDir,[mfilename '_PoissonMeanSDRatio']),poissSDMeanRatio,figParams.figType); 
    end
    
    % Can slso look at how the standard deviation over the mean grows,
    % which is how threshold would vary when expressed as contrast.
    if (runTimeParams.generatePlots)
        [poissSDMeanContrastRatio,figParams] = cbFigInit;
        figParams.xLimLow = 10^0;
        figParams.xLimHigh = 10^6;
        figParams.xTicks = [10^0 10^1 10^2 10^3 10^4 10^5 10^6];
        figParams.xTickLabels = {'^{ }10^{0}_{ }' '^{ }10^{1}_{ }' '^{ }10^{2}_{ }' '^{ }10^{3}_{ }' '^{ }10^{4}_{ }' '^{ }10^{5}_{ }' '^{ }10^{6}_{ }'};
        figParams.yLimLow = 0;
        figParams.yLimHigh = 1;
        figParams.yTicks = [0 0.2 0.4 0.6 0.8 1];
        figParams.yTickLabels = {' 0.0 ' '  0.2 ' '  0.4 ' '  0.6 ' '  0.8 ' '  1.0 '};
        
        % For semilog, need hold off for first plot, otherwise don't get
        % seimilog axis.  Go figure.
        hold off;
        semilogx(data.theMeans,data.theSDs./data.theMeans,'r','LineWidth',figParams.lineWidth);
        hold on; 
        
        xlabel('Background Quanta','FontSize',figParams.labelFontSize);
        ylabel('Standard Deviation (contrast)','FontSize',figParams.labelFontSize);
        title('Poisson Noise Limits','FontSize',figParams.titleFontSize);
        cbFigAxisSet(poissSDMeanContrastRatio,figParams);
        
        % Save the plot
        FigureSave(fullfile(outputDir,[mfilename '_PoissonMeanSDContrastRatio']),poissSDMeanContrastRatio,figParams.figType); 
    end
    
    %% Save validation data
    %
    % Strip out some of the really big stuff.
    theData = rmfield(theData,'scene');
    theData = rmfield(theData,'oi');
    theData.partialIrradiance = theData.oiIrradiance_PhotonsPerSecM2Nm(1:10,100:110,8);
    theData = rmfield(theData,'oiIrradiance_PhotonsPerSecM2Nm');
    UnitTest.validationData('theData', theData); 
    
    %% Restore warning state
    warning(warnS.state,warnS.identifier);
    
catch err
    %% Restore warning state
    warning(warnS.state,warnS.identifier);
    
    %% Rethrow error
    rethrow(err);
end

end



##### SOURCE END #####
--></body></html>