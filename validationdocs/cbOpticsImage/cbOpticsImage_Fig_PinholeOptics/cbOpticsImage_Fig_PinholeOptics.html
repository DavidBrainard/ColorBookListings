
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>cbOpticsImage_Fig_PinholeOptics</title><meta name="generator" content="MATLAB 8.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2015-07-02"><meta name="DC.source" content="cbOpticsImage_Fig_PinholeOptics.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">Function implementing the isetbio validation code</a></li><li><a href="#4">Hello</a></li><li><a href="#5">Set parameters</a></li><li><a href="#6">Compute diffraction blur for each pupil size</a></li><li><a href="#7">Compute equivalent blur circle</a></li><li><a href="#8">Plot a slice of the diffraction limited psf</a></li><li><a href="#9">Compute geometric blur for a pinhole optics.</a></li><li><a href="#10">Plot a slice through the geometric blur circle</a></li><li><a href="#11">Save validation data</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> varargout = cbOpticsImage_Fig_PinholeOptics(varargin)
<span class="comment">%</span>
<span class="comment">% Explore geometric and diffraction optical blur for a pinhole eye.</span>
<span class="comment">%</span>
<span class="comment">% The default parameters show results for an eye about the size of the</span>
<span class="comment">% human eye but for much smaller pupils.  The pupil sizes chosen illustrate</span>
<span class="comment">% a range where the factor limiting the size of the PSF switches between</span>
<span class="comment">% diffraction and the geometry of image formation.</span>
<span class="comment">%</span>
<span class="comment">% To see this, run the script and compare the two figures.  For the smaller</span>
<span class="comment">% pupil size, the diffraction limited blur is smaller than size of the</span>
<span class="comment">% geometric optics blur. For the larger pupil, this relation is reversed.</span>
<span class="comment">% For the intermediate pupil size (no figure, see printout to command</span>
<span class="comment">% window), the blur from the two factors is about the same. Note that the</span>
<span class="comment">% regime where the crossover happens is for pupils of the order of 0.1 mm</span>
<span class="comment">% in diameter, about 10 times smaller than the human pupil.</span>
<span class="comment">%</span>
<span class="comment">% Also note that the size of the blur for a pinhole camera with these pupil</span>
<span class="comment">% sizes is considerably larger than that of the real human eye, which has</span>
<span class="comment">% an optical resolution about 10 times better, that is aPSF about 10 times</span>
<span class="comment">% smaller).</span>
<span class="comment">%</span>
<span class="comment">% Possible extensions for the interested reader:</span>
<span class="comment">% - Examine how the relation between the two types of blur depends on what</span>
<span class="comment">% PSF volume is chosen to compute the equivalent blur circle.</span>
<span class="comment">% - Compare the blur circles here computed with the size of the real human</span>
<span class="comment">% PSF.</span>
<span class="comment">% - Examine how the blur due to diffraction depends on wavelength.</span>
<span class="comment">% - Examine how the geometric blur varies with distance to the object.</span>
<span class="comment">% This begins to get at the concept of depth of field.</span>
<span class="comment">%</span>
<span class="comment">% (c) David Brainard and Andrew Stockman, 2014</span>

    varargout = UnitTest.runValidationRun(@ValidationFunction, nargout, varargin);
<span class="keyword">end</span>
</pre><h2>Function implementing the isetbio validation code<a name="2"></a></h2><pre class="codeinput"><span class="keyword">function</span> ValidationFunction(runTimeParams)
</pre><h2>Hello<a name="4"></a></h2><pre class="codeinput">UnitTest.validationRecord(<span class="string">'SIMPLE_MESSAGE'</span>, sprintf(<span class="string">'%s'</span>,mfilename));
</pre><h2>Set parameters<a name="5"></a></h2><pre class="codeinput">calcParams.eyeDiameterMm = 24;
calcParams.wavelengthNm = 550;
calcParams.distanceToSourceMm = 2000;
calcParams.eqCriterionPSFFraction = 0.8;
calcParams.pupilDiametersMm = [0.05 0.1 0.2];
nPupilDiameters = length(calcParams.pupilDiametersMm);
</pre><h2>Compute diffraction blur for each pupil size<a name="6"></a></h2><p>The Psychtoolbox routine AiryPattern does the work.</p><pre class="codeinput"><span class="comment">% Set up radii to compute on.  Start by specifying the range in retinal mm</span>
<span class="comment">% and then converting to degrees.</span>
retinalRadiiMm = 0.5;
retinalRadiiDeg = RetinalMMToDegrees(retinalRadiiMm,calcParams.eyeDiameterMm);
retinalRadiiRad = degtorad(retinalRadiiDeg);

<span class="comment">% Set up grid matrices, so that we can convert radius to two-dimensional</span>
<span class="comment">% image. Although it is probably inefficient to compute on all the radii of</span>
<span class="comment">% a square image matrix (as opposed to computing for linear radii and then</span>
<span class="comment">% propogating the andser onto an image), computers are fast enough that we</span>
<span class="comment">% don't care.</span>
nPixels = 501;
centerPixel = round(nPixels+1)/2;
radiusMatrixRaw = MakeRadiusMat(nPixels,nPixels,centerPixel,centerPixel)/nPixels;
radiusMatrixDegs = retinalRadiiDeg*radiusMatrixRaw;
radiusMatrixRad = retinalRadiiRad*radiusMatrixRaw;
radiusMatrixMm = retinalRadiiMm*radiusMatrixRaw;
radiusLineMm = radiusMatrixMm(centerPixel,centerPixel:end);

<span class="comment">% Do the calculation for each pupil size and normalize volume of PSF to</span>
<span class="comment">% unity.  Also extract 1d slice.</span>
<span class="keyword">for</span> p = 1:length(calcParams.pupilDiametersMm)
    pupilDiameterMm = calcParams.pupilDiametersMm(p);
    diffractionPSFImage{p} = AiryPattern(radiusMatrixRad,pupilDiameterMm,calcParams.wavelengthNm);
    diffractionPSFImage{p} = diffractionPSFImage{p}/sum(diffractionPSFImage{p}(:));
    diffractionPSFSlice{p} = diffractionPSFImage{p}(centerPixel,centerPixel:end);
<span class="keyword">end</span>
</pre><h2>Compute equivalent blur circle<a name="7"></a></h2><p>For comparison with geometric blur, it is convenient to characterize the diffraction limited PSF by an equivalent blur circle.  We do this by finding the radius that contains a criterion fraction of the pupil volume, and calling that the equivlent cirular psf. This is a rough and ready approximation, but we find it conceptually convenient as a summary of the size of the PSF.</p><pre class="codeinput">radiiMm = unique(radiusMatrixMm(:));
<span class="keyword">for</span> p = 1:length(calcParams.pupilDiametersMm)
    <span class="keyword">for</span> i = 2:length(radiiMm)
        index = find(radiusMatrixMm &lt;= radiiMm(i));
        volume(i) = sum(diffractionPSFImage{p}(index));
        <span class="keyword">if</span> (volume(i) &gt; calcParams.eqCriterionPSFFraction)
            lambda = (calcParams.eqCriterionPSFFraction-volume(i-1))/(volume(i)-volume(i-1));
            eqDiffractionBlurCircleDiameterMm(p) = (1-lambda)*radiiMm(i-1) + lambda*radiiMm(i);
            eqDiffractionBlurCircleDiameterDegs(p) = RetinalMMToDegrees(eqDiffractionBlurCircleDiameterMm(p),calcParams.eyeDiameterMm);
            <span class="keyword">break</span>;
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">% Compute circular psfs at the equivalent diameters</span>
    <span class="comment">%</span>
    <span class="comment">% Build the image</span>
    eqDiffractionPSFImageMm{p} = ones(size(radiusMatrixMm));
    index = find(radiusMatrixMm &gt; eqDiffractionBlurCircleDiameterMm(p));
    eqDiffractionPSFImageMm{p}(index) = 0;

    <span class="comment">% Normalize volume and extract slice</span>
    eqDiffractionPSFImageMm{p} = eqDiffractionPSFImageMm{p}/sum(eqDiffractionPSFImageMm{p}(:));
    eqDiffractionPSFSlice{p} = eqDiffractionPSFImageMm{p}(centerPixel,centerPixel:end);

    <span class="comment">% Print summary of this calculation</span>
    fprintf(<span class="string">'Pupil size %0.2f mm, diffraction equiv blur cicle (%d%% volume) %0.3f mm, %0.3f deg\n'</span>,<span class="keyword">...</span>
        calcParams.pupilDiametersMm(p),round(100*calcParams.eqCriterionPSFFraction),eqDiffractionBlurCircleDiameterMm(p),eqDiffractionBlurCircleDiameterDegs(p));
<span class="keyword">end</span>
fprintf(<span class="string">'\n'</span>);
</pre><pre class="codeoutput">Pupil size 0.05 mm, diffraction equiv blur cicle (80% volume) 0.180 mm, 0.430 deg
Pupil size 0.10 mm, diffraction equiv blur cicle (80% volume) 0.100 mm, 0.239 deg
Pupil size 0.20 mm, diffraction equiv blur cicle (80% volume) 0.054 mm, 0.128 deg

</pre><h2>Plot a slice of the diffraction limited psf<a name="8"></a></h2><p>The plot shows a slice through the center of the psf for two pupil sizes (the smallest and largest that we compute for.).</p><p>The plot works better to compare shapes if we normalize PSFs to max of 1 rather than to unit volume, but be aware that the height of the volume normalized PSF will be different as a function of pupil size.</p><p>The plot also shows radius of equivalent blur circle as dashed vertical lines.</p><pre class="codeinput"><span class="keyword">if</span> (runTimeParams.generatePlots)
    [diffractionSliceFig,diffractionSliceFigParams] = cbFigInit;
    diffractionSliceFigParams.xLimLow = 0;
    diffractionSliceFigParams.xLimHigh = 0.4;
    diffractionSliceFigParams.xTicks = [0 0.1 0.2 0.3 0.4];
    diffractionSliceFigParams.xTickLabels = {};
    diffractionSliceFigParams.yLimLow = 0;
    diffractionSliceFigParams.yLimHigh = 1;
    diffractionSliceFigParams.yTicks = [0.0 0.2 0.4 0.6 0.8 1];
    diffractionSliceFigParams.yTickLabels = {};
    plot(radiusLineMm,diffractionPSFSlice{1}/max(diffractionPSFSlice{1}),<span class="string">'r'</span>,<span class="string">'LineWidth'</span>,diffractionSliceFigParams.lineWidth);
    plot(radiusLineMm,diffractionPSFSlice{end}/max(diffractionPSFSlice{end}),<span class="string">'b'</span>,<span class="string">'LineWidth'</span>,diffractionSliceFigParams.lineWidth);
    plot([eqDiffractionBlurCircleDiameterMm(1) eqDiffractionBlurCircleDiameterMm(1)],[0 0.5],<span class="string">'r:'</span>,<span class="string">'LineWidth'</span>,diffractionSliceFigParams.lineWidth-1);
    plot([eqDiffractionBlurCircleDiameterMm(end) eqDiffractionBlurCircleDiameterMm(end)],[0 0.5],<span class="string">'b:'</span>,<span class="string">'LineWidth'</span>,diffractionSliceFigParams.lineWidth-1);
    xlabel(<span class="string">'Retinal Radius (mm)'</span>,<span class="string">'FontSize'</span>,diffractionSliceFigParams.labelFontSize);
    ylabel(<span class="string">'Point Spread Function'</span>,<span class="string">'FontSize'</span>,diffractionSliceFigParams.labelFontSize);
    title(<span class="string">'Pinhole Camera - Diffraction Limited Blur'</span>,<span class="string">'FontSize'</span>,diffractionSliceFigParams.titleFontSize);
    cbFigAxisSet(diffractionSliceFig,diffractionSliceFigParams);
    legend({sprintf(<span class="string">'Pupil: %0.2f mm'</span>,calcParams.pupilDiametersMm(1)) sprintf(<span class="string">'Pupil: %0.2f mm'</span>,calcParams.pupilDiametersMm(end))},<span class="string">'Location'</span>,<span class="string">'NorthEast'</span>,<span class="string">'FontSize'</span>,diffractionSliceFigParams.legendFontSize);
    FigureSave([mfilename <span class="string">'_BlurDiffractionSlice'</span>],diffractionSliceFig,diffractionSliceFigParams.figType);
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="cbOpticsImage_Fig_PinholeOptics_01.png" alt=""> <h2>Compute geometric blur for a pinhole optics.<a name="9"></a></h2><p>This depends on the distance to the object, and in the limit of a infitely distant point source is just the pupil diameter directly.</p><p>We think that the distance dependence is also true of diffraction, in the sense that using the Airy pattern as the PSF results from some approximations that treat the arriving wavefront as planar at the pupil.</p><p>In any case, we'll use a distance that is big with respect to the scale of the model eye.</p><pre class="codeinput"><span class="keyword">for</span> p = 1:length(calcParams.pupilDiametersMm)
    <span class="comment">% Geometric calculation</span>
    geometricBlurCircleDiameterMm(p)  = ((calcParams.distanceToSourceMm+calcParams.eyeDiameterMm)/calcParams.distanceToSourceMm)*calcParams.pupilDiametersMm(p);

    <span class="comment">% For a really fair comparison with diffraction, should find the</span>
    <span class="comment">% equivalent circle diameter, that contains the criterion fraction of</span>
    <span class="comment">% the volume.</span>
    eqGeometricBlurCircleDiameterMm(p) = sqrt(calcParams.eqCriterionPSFFraction)*geometricBlurCircleDiameterMm(p);
    eqGeometricBlurCircleDiameterDegs(p) = RetinalMMToDegrees(eqGeometricBlurCircleDiameterMm(p),calcParams.eyeDiameterMm);
    eqGeometricPSFImageMm{p} = ones(size(radiusMatrixMm));
    index = find(radiusMatrixMm &gt; geometricBlurCircleDiameterMm(p));
    eqGeometricPSFImageMm{p}(index) = 0;

    <span class="comment">% Normalize volume and extract slice</span>
    eqGeometricPSFImageMm{p} = eqGeometricPSFImageMm{p}/sum(eqGeometricPSFImageMm{p}(:));
    eqGeometricPSFSlice{p} = eqGeometricPSFImageMm{p}(centerPixel,centerPixel:end);

     <span class="comment">% Print summary of this calculation</span>
    fprintf(<span class="string">'Pupil size %0.2f mm, geometric equiv blur cicle (%d%% volume) %0.3f mm, %0.3f deg\n'</span>,<span class="keyword">...</span>
        calcParams.pupilDiametersMm(p),round(100*calcParams.eqCriterionPSFFraction),eqGeometricBlurCircleDiameterMm(p),eqGeometricBlurCircleDiameterDegs(p));
<span class="keyword">end</span>
fprintf(<span class="string">'\n'</span>);
</pre><pre class="codeoutput">Pupil size 0.05 mm, geometric equiv blur cicle (80% volume) 0.045 mm, 0.108 deg
Pupil size 0.10 mm, geometric equiv blur cicle (80% volume) 0.091 mm, 0.216 deg
Pupil size 0.20 mm, geometric equiv blur cicle (80% volume) 0.181 mm, 0.432 deg

</pre><h2>Plot a slice through the geometric blur circle<a name="10"></a></h2><p>The plot shows the geometry-limited PSF, which is just a circle. It doesn't look quite like a circle because of numerical precision issues in the 2D computation of the PSF implemented here, but the basic point is clear.</p><p>The plot also shows as a dashed line the radius that contains the same criterion fraction of the PSF mass as for the diffraction limited calculation.  This provides a metric that may be compared to the size of the same metric for the diffraction limited PSF.</p><pre class="codeinput"><span class="keyword">if</span> (runTimeParams.generatePlots)
    [geometricSliceFig,geometricSliceFigParams] = cbFigInit;
    geometricSliceFigParams.xLimLow = 0;
    geometricSliceFigParams.xLimHigh = 0.4;
    geometricSliceFigParams.xTicks = [0 0.1 0.2 0.3 0.4];
    geometricSliceFigParams.xTickLabels = {};
    geometricSliceFigParams.yLimLow = 0;
    geometricSliceFigParams.yLimHigh = 1;
    geometricSliceFigParams.yTicks = [0.0 0.2 0.4 0.6 0.8 1];
    geometricSliceFigParams.yTickLabels = {};
    plot(radiusLineMm,eqGeometricPSFSlice{1}/max(eqGeometricPSFSlice{1}),<span class="string">'r'</span>,<span class="string">'LineWidth'</span>,geometricSliceFigParams.lineWidth+1);
    plot(radiusLineMm,eqGeometricPSFSlice{end}/max(eqGeometricPSFSlice{end}),<span class="string">'b'</span>,<span class="string">'LineWidth'</span>,geometricSliceFigParams.lineWidth);
    plot([eqGeometricBlurCircleDiameterMm(1) eqGeometricBlurCircleDiameterMm(1)],[0 0.5],<span class="string">'r:'</span>,<span class="string">'LineWidth'</span>,geometricSliceFigParams.lineWidth-1);
    plot([eqGeometricBlurCircleDiameterMm(end) eqGeometricBlurCircleDiameterMm(end)],[0 0.5],<span class="string">'b:'</span>,<span class="string">'LineWidth'</span>,geometricSliceFigParams.lineWidth-1);
    xlabel(<span class="string">'Retinal Radius (mm)'</span>,<span class="string">'FontSize'</span>,geometricSliceFigParams.labelFontSize);
    ylabel(<span class="string">'Point Spread Function'</span>,<span class="string">'FontSize'</span>,geometricSliceFigParams.labelFontSize);
    title(<span class="string">'Pinhole Camera - Geometric Optics Limited Blur'</span>,<span class="string">'FontSize'</span>,geometricSliceFigParams.titleFontSize);
    cbFigAxisSet(geometricSliceFig,geometricSliceFigParams);
    legend({sprintf(<span class="string">'Pupil: %0.2f mm'</span>,calcParams.pupilDiametersMm(1)) sprintf(<span class="string">'Pupil: %0.2f mm'</span>,calcParams.pupilDiametersMm(end))},<span class="string">'Location'</span>,<span class="string">'NorthEast'</span>,<span class="string">'FontSize'</span>,geometricSliceFigParams.legendFontSize);
    FigureSave([mfilename <span class="string">'_BlurGeometricSlice'</span>],geometricSliceFig,geometricSliceFigParams.figType);
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="cbOpticsImage_Fig_PinholeOptics_02.png" alt=""> <h2>Save validation data<a name="11"></a></h2><pre class="codeinput">UnitTest.validationData(<span class="string">'calcParams'</span>, calcParams);
UnitTest.validationData(<span class="string">'diffractionPSFSlice'</span>, diffractionPSFSlice);
UnitTest.validationData(<span class="string">'eqGeometricBlurCircleDiameterMm'</span>, eqGeometricBlurCircleDiameterMm);
UnitTest.validationData(<span class="string">'eqGeometricPSFSlice'</span>, eqGeometricPSFSlice);
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2014b</a><br></p></div><!--
##### SOURCE BEGIN #####
function varargout = cbOpticsImage_Fig_PinholeOptics(varargin)
%
% Explore geometric and diffraction optical blur for a pinhole eye.
%
% The default parameters show results for an eye about the size of the
% human eye but for much smaller pupils.  The pupil sizes chosen illustrate
% a range where the factor limiting the size of the PSF switches between
% diffraction and the geometry of image formation.
%
% To see this, run the script and compare the two figures.  For the smaller
% pupil size, the diffraction limited blur is smaller than size of the
% geometric optics blur. For the larger pupil, this relation is reversed.
% For the intermediate pupil size (no figure, see printout to command
% window), the blur from the two factors is about the same. Note that the
% regime where the crossover happens is for pupils of the order of 0.1 mm
% in diameter, about 10 times smaller than the human pupil.
%
% Also note that the size of the blur for a pinhole camera with these pupil
% sizes is considerably larger than that of the real human eye, which has
% an optical resolution about 10 times better, that is aPSF about 10 times
% smaller).
%
% Possible extensions for the interested reader:
% - Examine how the relation between the two types of blur depends on what
% PSF volume is chosen to compute the equivalent blur circle.
% - Compare the blur circles here computed with the size of the real human
% PSF.
% - Examine how the blur due to diffraction depends on wavelength.
% - Examine how the geometric blur varies with distance to the object.
% This begins to get at the concept of depth of field.
%
% (c) David Brainard and Andrew Stockman, 2014

    varargout = UnitTest.runValidationRun(@ValidationFunction, nargout, varargin);
end

%% Function implementing the isetbio validation code
function ValidationFunction(runTimeParams)

%% Hello
UnitTest.validationRecord('SIMPLE_MESSAGE', sprintf('%s',mfilename));

%% Set parameters
calcParams.eyeDiameterMm = 24;
calcParams.wavelengthNm = 550;
calcParams.distanceToSourceMm = 2000;
calcParams.eqCriterionPSFFraction = 0.8;
calcParams.pupilDiametersMm = [0.05 0.1 0.2];
nPupilDiameters = length(calcParams.pupilDiametersMm);

%% Compute diffraction blur for each pupil size
% The Psychtoolbox routine AiryPattern does the work.

% Set up radii to compute on.  Start by specifying the range in retinal mm
% and then converting to degrees.
retinalRadiiMm = 0.5;
retinalRadiiDeg = RetinalMMToDegrees(retinalRadiiMm,calcParams.eyeDiameterMm);
retinalRadiiRad = degtorad(retinalRadiiDeg);

% Set up grid matrices, so that we can convert radius to two-dimensional
% image. Although it is probably inefficient to compute on all the radii of
% a square image matrix (as opposed to computing for linear radii and then
% propogating the andser onto an image), computers are fast enough that we
% don't care.
nPixels = 501;
centerPixel = round(nPixels+1)/2;
radiusMatrixRaw = MakeRadiusMat(nPixels,nPixels,centerPixel,centerPixel)/nPixels;
radiusMatrixDegs = retinalRadiiDeg*radiusMatrixRaw;
radiusMatrixRad = retinalRadiiRad*radiusMatrixRaw;
radiusMatrixMm = retinalRadiiMm*radiusMatrixRaw;
radiusLineMm = radiusMatrixMm(centerPixel,centerPixel:end);

% Do the calculation for each pupil size and normalize volume of PSF to
% unity.  Also extract 1d slice.
for p = 1:length(calcParams.pupilDiametersMm)
    pupilDiameterMm = calcParams.pupilDiametersMm(p);
    diffractionPSFImage{p} = AiryPattern(radiusMatrixRad,pupilDiameterMm,calcParams.wavelengthNm); 
    diffractionPSFImage{p} = diffractionPSFImage{p}/sum(diffractionPSFImage{p}(:));
    diffractionPSFSlice{p} = diffractionPSFImage{p}(centerPixel,centerPixel:end);
end

%% Compute equivalent blur circle
% For comparison with geometric blur, it is convenient to characterize the
% diffraction limited PSF by an equivalent blur circle.  We do this by
% finding the radius that contains a criterion fraction of the pupil
% volume, and calling that the equivlent cirular psf. This is a rough and
% ready approximation, but we find it conceptually convenient as a summary
% of the size of the PSF.
radiiMm = unique(radiusMatrixMm(:));
for p = 1:length(calcParams.pupilDiametersMm)
    for i = 2:length(radiiMm)
        index = find(radiusMatrixMm <= radiiMm(i));
        volume(i) = sum(diffractionPSFImage{p}(index));
        if (volume(i) > calcParams.eqCriterionPSFFraction)
            lambda = (calcParams.eqCriterionPSFFraction-volume(i-1))/(volume(i)-volume(i-1));
            eqDiffractionBlurCircleDiameterMm(p) = (1-lambda)*radiiMm(i-1) + lambda*radiiMm(i);
            eqDiffractionBlurCircleDiameterDegs(p) = RetinalMMToDegrees(eqDiffractionBlurCircleDiameterMm(p),calcParams.eyeDiameterMm);
            break;
        end
    end
    
    % Compute circular psfs at the equivalent diameters
    %
    % Build the image
    eqDiffractionPSFImageMm{p} = ones(size(radiusMatrixMm));
    index = find(radiusMatrixMm > eqDiffractionBlurCircleDiameterMm(p));
    eqDiffractionPSFImageMm{p}(index) = 0;
    
    % Normalize volume and extract slice
    eqDiffractionPSFImageMm{p} = eqDiffractionPSFImageMm{p}/sum(eqDiffractionPSFImageMm{p}(:));
    eqDiffractionPSFSlice{p} = eqDiffractionPSFImageMm{p}(centerPixel,centerPixel:end);
    
    % Print summary of this calculation
    fprintf('Pupil size %0.2f mm, diffraction equiv blur cicle (%d%% volume) %0.3f mm, %0.3f deg\n',...
        calcParams.pupilDiametersMm(p),round(100*calcParams.eqCriterionPSFFraction),eqDiffractionBlurCircleDiameterMm(p),eqDiffractionBlurCircleDiameterDegs(p));
end
fprintf('\n');

%% Plot a slice of the diffraction limited psf
% The plot shows a slice through the center of the psf for two pupil sizes
% (the smallest and largest that we compute for.).
%
% The plot works better to compare shapes if we normalize PSFs to max of 1
% rather than to unit volume, but be aware that the height of the volume
% normalized PSF will be different as a function of pupil size.
%
% The plot also shows radius of equivalent blur circle as dashed vertical
% lines.
if (runTimeParams.generatePlots)
    [diffractionSliceFig,diffractionSliceFigParams] = cbFigInit;
    diffractionSliceFigParams.xLimLow = 0;
    diffractionSliceFigParams.xLimHigh = 0.4;
    diffractionSliceFigParams.xTicks = [0 0.1 0.2 0.3 0.4];
    diffractionSliceFigParams.xTickLabels = {};
    diffractionSliceFigParams.yLimLow = 0;
    diffractionSliceFigParams.yLimHigh = 1;
    diffractionSliceFigParams.yTicks = [0.0 0.2 0.4 0.6 0.8 1];
    diffractionSliceFigParams.yTickLabels = {};
    plot(radiusLineMm,diffractionPSFSlice{1}/max(diffractionPSFSlice{1}),'r','LineWidth',diffractionSliceFigParams.lineWidth);
    plot(radiusLineMm,diffractionPSFSlice{end}/max(diffractionPSFSlice{end}),'b','LineWidth',diffractionSliceFigParams.lineWidth);
    plot([eqDiffractionBlurCircleDiameterMm(1) eqDiffractionBlurCircleDiameterMm(1)],[0 0.5],'r:','LineWidth',diffractionSliceFigParams.lineWidth-1);
    plot([eqDiffractionBlurCircleDiameterMm(end) eqDiffractionBlurCircleDiameterMm(end)],[0 0.5],'b:','LineWidth',diffractionSliceFigParams.lineWidth-1);
    xlabel('Retinal Radius (mm)','FontSize',diffractionSliceFigParams.labelFontSize);
    ylabel('Point Spread Function','FontSize',diffractionSliceFigParams.labelFontSize);
    title('Pinhole Camera - Diffraction Limited Blur','FontSize',diffractionSliceFigParams.titleFontSize);
    cbFigAxisSet(diffractionSliceFig,diffractionSliceFigParams);
    legend({sprintf('Pupil: %0.2f mm',calcParams.pupilDiametersMm(1)) sprintf('Pupil: %0.2f mm',calcParams.pupilDiametersMm(end))},'Location','NorthEast','FontSize',diffractionSliceFigParams.legendFontSize);
    FigureSave([mfilename '_BlurDiffractionSlice'],diffractionSliceFig,diffractionSliceFigParams.figType);
end

%% Compute geometric blur for a pinhole optics.
% This depends on the distance to the object, and in the limit of a
% infitely distant point source is just the pupil diameter directly.
%
% We think that the distance dependence is also true of diffraction, in the
% sense that using the Airy pattern as the PSF results from some
% approximations that treat the arriving wavefront as planar at the pupil.
%
% In any case, we'll use a distance that is big with respect to the scale
% of the model eye.
for p = 1:length(calcParams.pupilDiametersMm)
    % Geometric calculation
    geometricBlurCircleDiameterMm(p)  = ((calcParams.distanceToSourceMm+calcParams.eyeDiameterMm)/calcParams.distanceToSourceMm)*calcParams.pupilDiametersMm(p);
    
    % For a really fair comparison with diffraction, should find the
    % equivalent circle diameter, that contains the criterion fraction of
    % the volume.
    eqGeometricBlurCircleDiameterMm(p) = sqrt(calcParams.eqCriterionPSFFraction)*geometricBlurCircleDiameterMm(p);
    eqGeometricBlurCircleDiameterDegs(p) = RetinalMMToDegrees(eqGeometricBlurCircleDiameterMm(p),calcParams.eyeDiameterMm);
    eqGeometricPSFImageMm{p} = ones(size(radiusMatrixMm));
    index = find(radiusMatrixMm > geometricBlurCircleDiameterMm(p));
    eqGeometricPSFImageMm{p}(index) = 0;
    
    % Normalize volume and extract slice
    eqGeometricPSFImageMm{p} = eqGeometricPSFImageMm{p}/sum(eqGeometricPSFImageMm{p}(:));
    eqGeometricPSFSlice{p} = eqGeometricPSFImageMm{p}(centerPixel,centerPixel:end);
    
     % Print summary of this calculation
    fprintf('Pupil size %0.2f mm, geometric equiv blur cicle (%d%% volume) %0.3f mm, %0.3f deg\n',...
        calcParams.pupilDiametersMm(p),round(100*calcParams.eqCriterionPSFFraction),eqGeometricBlurCircleDiameterMm(p),eqGeometricBlurCircleDiameterDegs(p));
end
fprintf('\n');

%% Plot a slice through the geometric blur circle
% The plot shows the geometry-limited PSF, which is just a circle. It
% doesn't look quite like a circle because of numerical precision issues in
% the 2D computation of the PSF implemented here, but the basic point is
% clear.
%
% The plot also shows as a dashed line the radius that contains the same
% criterion fraction of the PSF mass as for the diffraction limited
% calculation.  This provides a metric that may be compared to the size of
% the same metric for the diffraction limited PSF.
if (runTimeParams.generatePlots)
    [geometricSliceFig,geometricSliceFigParams] = cbFigInit;
    geometricSliceFigParams.xLimLow = 0;
    geometricSliceFigParams.xLimHigh = 0.4;
    geometricSliceFigParams.xTicks = [0 0.1 0.2 0.3 0.4];
    geometricSliceFigParams.xTickLabels = {};
    geometricSliceFigParams.yLimLow = 0;
    geometricSliceFigParams.yLimHigh = 1;
    geometricSliceFigParams.yTicks = [0.0 0.2 0.4 0.6 0.8 1];
    geometricSliceFigParams.yTickLabels = {};
    plot(radiusLineMm,eqGeometricPSFSlice{1}/max(eqGeometricPSFSlice{1}),'r','LineWidth',geometricSliceFigParams.lineWidth+1);
    plot(radiusLineMm,eqGeometricPSFSlice{end}/max(eqGeometricPSFSlice{end}),'b','LineWidth',geometricSliceFigParams.lineWidth);
    plot([eqGeometricBlurCircleDiameterMm(1) eqGeometricBlurCircleDiameterMm(1)],[0 0.5],'r:','LineWidth',geometricSliceFigParams.lineWidth-1);
    plot([eqGeometricBlurCircleDiameterMm(end) eqGeometricBlurCircleDiameterMm(end)],[0 0.5],'b:','LineWidth',geometricSliceFigParams.lineWidth-1);
    xlabel('Retinal Radius (mm)','FontSize',geometricSliceFigParams.labelFontSize);
    ylabel('Point Spread Function','FontSize',geometricSliceFigParams.labelFontSize);
    title('Pinhole Camera - Geometric Optics Limited Blur','FontSize',geometricSliceFigParams.titleFontSize);
    cbFigAxisSet(geometricSliceFig,geometricSliceFigParams);
    legend({sprintf('Pupil: %0.2f mm',calcParams.pupilDiametersMm(1)) sprintf('Pupil: %0.2f mm',calcParams.pupilDiametersMm(end))},'Location','NorthEast','FontSize',geometricSliceFigParams.legendFontSize);
    FigureSave([mfilename '_BlurGeometricSlice'],geometricSliceFig,geometricSliceFigParams.figType);
end

%% Save validation data
UnitTest.validationData('calcParams', calcParams);
UnitTest.validationData('diffractionPSFSlice', diffractionPSFSlice);
UnitTest.validationData('eqGeometricBlurCircleDiameterMm', eqGeometricBlurCircleDiameterMm);
UnitTest.validationData('eqGeometricPSFSlice', eqGeometricPSFSlice);

end








##### SOURCE END #####
--></body></html>