
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>cbOpticsImage_AngleToMm</title><meta name="generator" content="MATLAB 8.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2015-08-06"><meta name="DC.source" content="cbOpticsImage_AngleToMm.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">Function implementing the isetbio validation code</a></li><li><a href="#4">Hello</a></li><li><a href="#5">Set parameters</a></li><li><a href="#6">Simple trigonometric calculation</a></li><li><a href="#7">Degrees to Mm calculations</a></li><li><a href="#8">Mm to degrees calculations</a></li><li><a href="#9">Drasdo and Fowler Figure 2</a></li><li><a href="#10">Make a figure for the box</a></li><li><a href="#11">Can also make the inverse figure.</a></li><li><a href="#12">Save validation data</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> varargout = cbOpticsImage_AngleToMm(varargin)
<span class="comment">%</span>
<span class="comment">% Illustrates calculations converting degrees of visual angle to mm.</span>
<span class="comment">%</span>
<span class="comment">% Makes plots of eccentricity in mm versus eccentricity in degrees and the</span>
<span class="comment">% other way around.</span>
<span class="comment">%</span>
<span class="comment">% The underlying routines are in the Psychophysics Toolbox.</span>
<span class="comment">%</span>
<span class="comment">% (c) David Brainard and Andrew Stockman, 2015</span>

    varargout = UnitTest.runValidationRun(@ValidationFunction, nargout, varargin);
<span class="keyword">end</span>
</pre><h2>Function implementing the isetbio validation code<a name="2"></a></h2><pre class="codeinput"><span class="keyword">function</span> ValidationFunction(runTimeParams)
</pre><h2>Hello<a name="4"></a></h2><pre class="codeinput">UnitTest.validationRecord(<span class="string">'SIMPLE_MESSAGE'</span>, sprintf(<span class="string">'%s'</span>,mfilename));
outputDir = sprintf(<span class="string">'%s_Output'</span>,mfilename);
<span class="keyword">if</span> (~exist(outputDir,<span class="string">'dir'</span>))
    mkdir(outputDir);
<span class="keyword">end</span>
</pre><h2>Set parameters<a name="5"></a></h2><p>Can calculate with parameters set either for 'Human' or for 'Rhesus' eye.</p><pre class="codeinput">species = <span class="string">'Human'</span>;
<span class="keyword">switch</span> (species)
    <span class="keyword">case</span> <span class="string">'Human'</span>
        data.eyeLengthMm = EyeLength(species,<span class="string">'Rodieck'</span>);
    <span class="keyword">case</span> <span class="string">'Rhesus'</span>
        data.eyeLengthMm = EyeLength(species,<span class="string">'PerryCowey'</span>);
    <span class="keyword">otherwise</span>
        error(<span class="string">'Unknown species specified'</span>);
<span class="keyword">end</span>
</pre><h2>Simple trigonometric calculation<a name="6"></a></h2><pre class="codeinput">degPerMm = DegreesToRetinalMM(1,data.eyeLengthMm);
mmPerDeg = RetinalMMToDegrees(1,data.eyeLengthMm);
fprintf(<span class="string">'Computing for species %s\n'</span>,species);
fprintf(<span class="string">'\tMm per degree, linear approximation: %0.2f, assuming nodal point to retina of %0.1f mm\n'</span>,degPerMm,data.eyeLengthMm);
fprintf(<span class="string">'\tCorresponding degrees per mm: %0.1f\n'</span>,mmPerDeg);
tolerance = 1e-6;
UnitTest.assertIsZero(abs(degPerMm*mmPerDeg-1),<span class="string">'Linear calculation self-inversion check'</span>,tolerance);
</pre><pre class="codeoutput">Computing for species Human
	Mm per degree, linear approximation: 0.28, assuming nodal point to retina of 16.1 mm
	Corresponding degrees per mm: 3.6
</pre><h2>Degrees to Mm calculations<a name="7"></a></h2><pre class="codeinput">upperLimitDegrees = 100;
data.eccDegrees = linspace(0,upperLimitDegrees,100);
data.eccMm = DegreesToRetinalEccentricityMM(data.eccDegrees,species,<span class="string">'DaceyPeterson'</span>);
data.eccMmLinear = DegreesToRetinalEccentricityMM(data.eccDegrees,species,<span class="string">'Linear'</span>,data.eyeLengthMm);
data.eccDegreesCheck =  RetinalEccentricityMMToDegrees(data.eccMm,species,<span class="string">'DaceyPeterson'</span>);
UnitTest.assertIsZero(abs(data.eccDegrees-data.eccDegreesCheck),<span class="string">'Conversion functions self-inversion check'</span>,tolerance);
</pre><h2>Mm to degrees calculations<a name="8"></a></h2><pre class="codeinput">upperLimitMm = 20;
data.eccMm1 = linspace(0,upperLimitMm,100);
data.eccDegrees1 = RetinalEccentricityMMToDegrees(data.eccMm1,species,<span class="string">'DaceyPeterson'</span>);
data.eccDegreesLinear1 = RetinalEccentricityMMToDegrees(data.eccMm1,species,<span class="string">'Linear'</span>,data.eyeLengthMm);
data.eccMmCheck1 = DegreesToRetinalEccentricityMM(data.eccDegrees1,species,<span class="string">'DaceyPeterson'</span>);
UnitTest.assertIsZero(abs(data.eccMm1-data.eccMmCheck1),<span class="string">'Conversion functions self-inversion check'</span>,tolerance);

<span class="comment">% This is the tangent calculation, which although it once seemed to me</span>
<span class="comment">% a better approximation than the pure linear approximation turns out to</span>
<span class="comment">% deviate more from the model eye based calculation.  Not plotted but you</span>
<span class="comment">% could be commenting out the corresponding lines in the plot code below.</span>
data.eccMmTangent = DegreesToRetinalMM(data.eccDegrees,data.eyeLengthMm,true);
data.eccDegreesTangent1 = RetinalMMToDegrees(data.eccMm1,data.eyeLengthMm,true);
</pre><h2>Drasdo and Fowler Figure 2<a name="9"></a></h2><p>This is ellipsoid model data, digitized from their figure.  It is not clear to me which curve (ellipsoid or sphere) Dacey and Peterson digitized and fit.  First column is degrees, second is mm.</p><pre class="codeinput">drasdoFowlerData = <span class="keyword">...</span>
    [1.429393919263E0	4.001594366571E-1
    3.492105671073E0	9.230850993158E-1
    6.034234593326E0	1.662020859629E0
    1.000354303683E1	2.739148342523E0
    1.571668991785E1	4.215850660998E0
    2.381363626298E1	6.400797183286E0
    3.286388095396E1	8.862844615691E0
    4.016364401337E1	1.073941407028E1
    4.572178303328E1	1.227837640337E1
    4.794503864125E1	1.289396133661E1
    4.984831373591E1	1.335521158573E1
    5.254323612126E1	1.396991961735E1
    5.523705130760E1	1.455364379194E1
    6.126021391085E1	1.590582608118E1
    6.632675657123E1	1.688795588919E1
    7.012555636750E1	1.759356938816E1
    7.503155517173E1	1.848303992560E1
    8.135698310414E1	1.949381518634E1
    8.689076374588E1	2.035113266459E1
    9.321065568325E1	2.120698864014E1
    9.921278150535E1	2.197047764565E1];
</pre><h2>Make a figure for the box<a name="10"></a></h2><p>By uncommenting the plot line for the Drasdo and Fowler data you can see that the approximation provided by the fit is so-so, although the formula is much closer to the Drasdo and Fowler curve than the linear approximation.  I don't think the juice is worth the squeeze as far as trying to do better with that figure, given individual differences and model eye differences.  If one wanted to go down that road, probably starting with a ray trace of our best current model eye would be the place to start.</p><pre class="codeinput"><span class="keyword">if</span> (runTimeParams.generatePlots)
    [angleToMmFig,figParams] = cbFigInit;
    figParams.xLimLow = 0;
    figParams.xLimHigh = 80;
    figParams.xTicks = [0 10 20 30 40 50 60 70 80];
    figParams.xTickLabels = {<span class="string">'^{ }0_{ }'</span> <span class="string">'^{ }10_{ }'</span> <span class="string">'^{ }20_{ }'</span> <span class="string">'^{ }30_{ }'</span> <span class="string">'^{ }40_{ }'</span> <span class="string">'^{ }50_{ }'</span> <span class="keyword">...</span>
        <span class="string">'^{ }60_{ }'</span> <span class="string">'^{ }70_{ }'</span> };
    figParams.yLimLow = 0;
    figParams.yLimHigh = 25;
    figParams.yTicks = [0 5 10 15 20 25];
    figParams.yTickLabels = {<span class="string">'  0 '</span> <span class="string">'  5 '</span> <span class="string">' 10 '</span> <span class="string">' 15 '</span> <span class="string">' 20 '</span> <span class="string">' 25 '</span>};

    plot(data.eccDegrees,data.eccMmLinear,<span class="string">'b--'</span>,<span class="string">'LineWidth'</span>,figParams.lineWidth);
    plot(data.eccDegrees,data.eccMm,<span class="string">'r'</span>,<span class="string">'LineWidth'</span>,figParams.lineWidth);
    <span class="comment">% plot(data.eccDegrees,data.eccMmTangent,'g','LineWidth',figParams.lineWidth);</span>
    <span class="comment">% plot(drasdoFowlerData(:,1),drasdoFowlerData(:,2),'k--','LineWidth',figParams.lineWidth-1);</span>

    xlabel(<span class="string">'Eccentricity (degrees)'</span>,<span class="string">'FontSize'</span>,figParams.labelFontSize);
    ylabel(<span class="string">'Eccentricity (mm)'</span>,<span class="string">'FontSize'</span>,figParams.labelFontSize);
    title(<span class="string">'Eccentricity Conversion'</span>,<span class="string">'FontSize'</span>,figParams.titleFontSize);
    cbFigAxisSet(angleToMmFig,figParams);

    <span class="comment">% Legend, with tweak to make lines long enough so that dash shows.</span>
    <span class="comment">% Note the extra spaces that preface the actual legend text. Ugh.</span>
    [~,legendChildObjs] = legend({[<span class="string">'^{ }'</span> figParams.legendExtraSpaceStr <span class="string">'  Linear '</span>],[ <span class="string">'^{ }'</span> figParams.legendExtraSpaceStr <span class="string">'  Model Eye Based '</span>]},<span class="keyword">...</span>
        <span class="string">'Location'</span>,<span class="string">'NorthWest'</span>,<span class="string">'FontSize'</span>,figParams.legendFontSize);
    lineObjs = findobj(legendChildObjs, <span class="string">'Type'</span>, <span class="string">'line'</span>);
    xCoords = get(lineObjs, <span class="string">'XData'</span>) ;
    <span class="keyword">for</span> lineIdx = 1:length(xCoords)
        <span class="keyword">if</span> (length(xCoords{lineIdx}) ~= 2), <span class="keyword">continue</span>; <span class="keyword">end</span>
        set(lineObjs(lineIdx), <span class="string">'XData'</span>, xCoords{lineIdx} + [0 figParams.legendLineTweak])
    <span class="keyword">end</span>

    FigureSave(fullfile(outputDir,[mfilename <span class="string">'_ConvertAngleToMm'</span>]),angleToMmFig,figParams.figType);
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="cbOpticsImage_AngleToMm_01.png" alt=""> <h2>Can also make the inverse figure.<a name="11"></a></h2><pre class="codeinput"><span class="keyword">if</span> (runTimeParams.generatePlots)
    [mmToAngleFig,figParams] = cbFigInit;
    figParams.xLimLow = 0;
    figParams.xLimHigh = 25;
    figParams.xTicks = [0 5 10 15 20 25];
    figParams.xTickLabels = {<span class="string">'^{ }0_{ }'</span> <span class="string">'^{ }5_{ }'</span> <span class="string">'^{ }10_{ }'</span> <span class="string">'^{ }15_{ }'</span> <span class="string">'^{ }20_{ }'</span> <span class="string">'^{ }25_{ }'</span>};
    figParams.yLimLow = 0;
    figParams.yLimHigh = 80;
    figParams.yTicks = [0 10 20 30 40 50 60 70 80];
    figParams.yTickLabels = {<span class="string">'  0 '</span> <span class="string">' 10 '</span> <span class="string">' 20 '</span> <span class="string">' 30 '</span> <span class="string">' 40 '</span> <span class="string">' 50 '</span> <span class="string">' 60 '</span> <span class="string">' 70 '</span> <span class="string">' 80 '</span>};

    plot(data.eccMm1,data.eccDegreesLinear1,<span class="string">'b--'</span>,<span class="string">'LineWidth'</span>,figParams.lineWidth);
    plot(data.eccMm1,data.eccDegrees1,<span class="string">'r'</span>,<span class="string">'LineWidth'</span>,figParams.lineWidth);
    <span class="comment">% plot(data.eccMm1,data.eccDegreesTangent1,'g','LineWidth',figParams.lineWidth);</span>

    xlabel(<span class="string">'Eccentricity (mm)'</span>,<span class="string">'FontSize'</span>,figParams.labelFontSize);
    ylabel(<span class="string">'Eccentricity (degrees)'</span>,<span class="string">'FontSize'</span>,figParams.labelFontSize);
    title(<span class="string">'Eccentricity Conversion'</span>,<span class="string">'FontSize'</span>,figParams.titleFontSize);
    cbFigAxisSet(mmToAngleFig,figParams);

    <span class="comment">% Legend, with tweak to make lines long enough so that dash shows.</span>
    <span class="comment">% Note the extra spaces that preface the actual legend text. Ugh.</span>
    [~,legendChildObjs] = legend({[<span class="string">'^{ }'</span> figParams.legendExtraSpaceStr <span class="string">'  Linear  '</span>],[ <span class="string">'^{ }'</span> figParams.legendExtraSpaceStr <span class="string">'  Model Eye Based  '</span>]},<span class="keyword">...</span>
        <span class="string">'Location'</span>,<span class="string">'NorthWest'</span>,<span class="string">'FontSize'</span>,figParams.legendFontSize);
    lineObjs = findobj(legendChildObjs, <span class="string">'Type'</span>, <span class="string">'line'</span>);
    xCoords = get(lineObjs, <span class="string">'XData'</span>) ;
    <span class="keyword">for</span> lineIdx = 1:length(xCoords)
        <span class="keyword">if</span> (length(xCoords{lineIdx}) ~= 2), <span class="keyword">continue</span>; <span class="keyword">end</span>
        set(lineObjs(lineIdx), <span class="string">'XData'</span>, xCoords{lineIdx} + [0 figParams.legendLineTweak])
    <span class="keyword">end</span>

    FigureSave(fullfile(outputDir,[mfilename <span class="string">'_ConvertMmToAngle'</span>]),mmToAngleFig,figParams.figType);
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="cbOpticsImage_AngleToMm_02.png" alt=""> <h2>Save validation data<a name="12"></a></h2><pre class="codeinput">UnitTest.validationData(<span class="string">'validateDataStruct'</span>, data);
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2014b</a><br></p></div><!--
##### SOURCE BEGIN #####
function varargout = cbOpticsImage_AngleToMm(varargin)
%
% Illustrates calculations converting degrees of visual angle to mm.
%
% Makes plots of eccentricity in mm versus eccentricity in degrees and the
% other way around.
%
% The underlying routines are in the Psychophysics Toolbox.
%
% (c) David Brainard and Andrew Stockman, 2015

    varargout = UnitTest.runValidationRun(@ValidationFunction, nargout, varargin);
end

%% Function implementing the isetbio validation code
function ValidationFunction(runTimeParams)

%% Hello
UnitTest.validationRecord('SIMPLE_MESSAGE', sprintf('%s',mfilename));
outputDir = sprintf('%s_Output',mfilename);
if (~exist(outputDir,'dir'))
    mkdir(outputDir);
end

%% Set parameters
%
% Can calculate with parameters set either for
% 'Human' or for 'Rhesus' eye.
species = 'Human';
switch (species)
    case 'Human'
        data.eyeLengthMm = EyeLength(species,'Rodieck');
    case 'Rhesus'
        data.eyeLengthMm = EyeLength(species,'PerryCowey');              
    otherwise
        error('Unknown species specified');
end

%% Simple trigonometric calculation
degPerMm = DegreesToRetinalMM(1,data.eyeLengthMm);
mmPerDeg = RetinalMMToDegrees(1,data.eyeLengthMm);
fprintf('Computing for species %s\n',species);
fprintf('\tMm per degree, linear approximation: %0.2f, assuming nodal point to retina of %0.1f mm\n',degPerMm,data.eyeLengthMm);
fprintf('\tCorresponding degrees per mm: %0.1f\n',mmPerDeg);
tolerance = 1e-6;
UnitTest.assertIsZero(abs(degPerMm*mmPerDeg-1),'Linear calculation self-inversion check',tolerance);

%% Degrees to Mm calculations
upperLimitDegrees = 100;
data.eccDegrees = linspace(0,upperLimitDegrees,100);
data.eccMm = DegreesToRetinalEccentricityMM(data.eccDegrees,species,'DaceyPeterson');
data.eccMmLinear = DegreesToRetinalEccentricityMM(data.eccDegrees,species,'Linear',data.eyeLengthMm);
data.eccDegreesCheck =  RetinalEccentricityMMToDegrees(data.eccMm,species,'DaceyPeterson');
UnitTest.assertIsZero(abs(data.eccDegrees-data.eccDegreesCheck),'Conversion functions self-inversion check',tolerance);

%% Mm to degrees calculations
upperLimitMm = 20;
data.eccMm1 = linspace(0,upperLimitMm,100);
data.eccDegrees1 = RetinalEccentricityMMToDegrees(data.eccMm1,species,'DaceyPeterson');
data.eccDegreesLinear1 = RetinalEccentricityMMToDegrees(data.eccMm1,species,'Linear',data.eyeLengthMm);
data.eccMmCheck1 = DegreesToRetinalEccentricityMM(data.eccDegrees1,species,'DaceyPeterson');
UnitTest.assertIsZero(abs(data.eccMm1-data.eccMmCheck1),'Conversion functions self-inversion check',tolerance);

% This is the tangent calculation, which although it once seemed to me
% a better approximation than the pure linear approximation turns out to
% deviate more from the model eye based calculation.  Not plotted but you
% could be commenting out the corresponding lines in the plot code below.
data.eccMmTangent = DegreesToRetinalMM(data.eccDegrees,data.eyeLengthMm,true);
data.eccDegreesTangent1 = RetinalMMToDegrees(data.eccMm1,data.eyeLengthMm,true);

%% Drasdo and Fowler Figure 2
%
% This is ellipsoid model data, digitized from their figure.  It is not
% clear to me which curve (ellipsoid or sphere) Dacey and Peterson
% digitized and fit.  First column is degrees, second is mm.
drasdoFowlerData = ...
    [1.429393919263E0	4.001594366571E-1
    3.492105671073E0	9.230850993158E-1
    6.034234593326E0	1.662020859629E0
    1.000354303683E1	2.739148342523E0
    1.571668991785E1	4.215850660998E0
    2.381363626298E1	6.400797183286E0
    3.286388095396E1	8.862844615691E0
    4.016364401337E1	1.073941407028E1
    4.572178303328E1	1.227837640337E1
    4.794503864125E1	1.289396133661E1
    4.984831373591E1	1.335521158573E1
    5.254323612126E1	1.396991961735E1
    5.523705130760E1	1.455364379194E1
    6.126021391085E1	1.590582608118E1
    6.632675657123E1	1.688795588919E1
    7.012555636750E1	1.759356938816E1
    7.503155517173E1	1.848303992560E1
    8.135698310414E1	1.949381518634E1
    8.689076374588E1	2.035113266459E1
    9.321065568325E1	2.120698864014E1
    9.921278150535E1	2.197047764565E1];

%% Make a figure for the box
%
% By uncommenting the plot line for the Drasdo and Fowler data
% you can see that the approximation provided by the fit is so-so,
% although the formula is much closer to the Drasdo and Fowler curve 
% than the linear approximation.  I don't think the juice is worth the
% squeeze as far as trying to do better with that figure, given individual
% differences and model eye differences.  If one wanted to go down that
% road, probably starting with a ray trace of our best current model eye
% would be the place to start.
if (runTimeParams.generatePlots)
    [angleToMmFig,figParams] = cbFigInit;
    figParams.xLimLow = 0;
    figParams.xLimHigh = 80;
    figParams.xTicks = [0 10 20 30 40 50 60 70 80]; 
    figParams.xTickLabels = {'^{ }0_{ }' '^{ }10_{ }' '^{ }20_{ }' '^{ }30_{ }' '^{ }40_{ }' '^{ }50_{ }' ...
        '^{ }60_{ }' '^{ }70_{ }' };
    figParams.yLimLow = 0;
    figParams.yLimHigh = 25;
    figParams.yTicks = [0 5 10 15 20 25];
    figParams.yTickLabels = {'  0 ' '  5 ' ' 10 ' ' 15 ' ' 20 ' ' 25 '};
    
    plot(data.eccDegrees,data.eccMmLinear,'bREPLACE_WITH_DASH_DASH','LineWidth',figParams.lineWidth);
    plot(data.eccDegrees,data.eccMm,'r','LineWidth',figParams.lineWidth);
    % plot(data.eccDegrees,data.eccMmTangent,'g','LineWidth',figParams.lineWidth);
    % plot(drasdoFowlerData(:,1),drasdoFowlerData(:,2),'kREPLACE_WITH_DASH_DASH','LineWidth',figParams.lineWidth-1);
    
    xlabel('Eccentricity (degrees)','FontSize',figParams.labelFontSize);
    ylabel('Eccentricity (mm)','FontSize',figParams.labelFontSize);
    title('Eccentricity Conversion','FontSize',figParams.titleFontSize);
    cbFigAxisSet(angleToMmFig,figParams);
    
    % Legend, with tweak to make lines long enough so that dash shows.
    % Note the extra spaces that preface the actual legend text. Ugh.
    [~,legendChildObjs] = legend({['^{ }' figParams.legendExtraSpaceStr '  Linear '],[ '^{ }' figParams.legendExtraSpaceStr '  Model Eye Based ']},...
        'Location','NorthWest','FontSize',figParams.legendFontSize);
    lineObjs = findobj(legendChildObjs, 'Type', 'line');
    xCoords = get(lineObjs, 'XData') ;
    for lineIdx = 1:length(xCoords)
        if (length(xCoords{lineIdx}) ~= 2), continue; end
        set(lineObjs(lineIdx), 'XData', xCoords{lineIdx} + [0 figParams.legendLineTweak])
    end
    
    FigureSave(fullfile(outputDir,[mfilename '_ConvertAngleToMm']),angleToMmFig,figParams.figType);
end

%% Can also make the inverse figure.
if (runTimeParams.generatePlots)
    [mmToAngleFig,figParams] = cbFigInit;
    figParams.xLimLow = 0;
    figParams.xLimHigh = 25;
    figParams.xTicks = [0 5 10 15 20 25];
    figParams.xTickLabels = {'^{ }0_{ }' '^{ }5_{ }' '^{ }10_{ }' '^{ }15_{ }' '^{ }20_{ }' '^{ }25_{ }'};
    figParams.yLimLow = 0;
    figParams.yLimHigh = 80;
    figParams.yTicks = [0 10 20 30 40 50 60 70 80];
    figParams.yTickLabels = {'  0 ' ' 10 ' ' 20 ' ' 30 ' ' 40 ' ' 50 ' ' 60 ' ' 70 ' ' 80 '};
    
    plot(data.eccMm1,data.eccDegreesLinear1,'bREPLACE_WITH_DASH_DASH','LineWidth',figParams.lineWidth);
    plot(data.eccMm1,data.eccDegrees1,'r','LineWidth',figParams.lineWidth);
    % plot(data.eccMm1,data.eccDegreesTangent1,'g','LineWidth',figParams.lineWidth);
    
    xlabel('Eccentricity (mm)','FontSize',figParams.labelFontSize);
    ylabel('Eccentricity (degrees)','FontSize',figParams.labelFontSize);
    title('Eccentricity Conversion','FontSize',figParams.titleFontSize);
    cbFigAxisSet(mmToAngleFig,figParams);
    
    % Legend, with tweak to make lines long enough so that dash shows.
    % Note the extra spaces that preface the actual legend text. Ugh.
    [~,legendChildObjs] = legend({['^{ }' figParams.legendExtraSpaceStr '  Linear  '],[ '^{ }' figParams.legendExtraSpaceStr '  Model Eye Based  ']},...
        'Location','NorthWest','FontSize',figParams.legendFontSize);
    lineObjs = findobj(legendChildObjs, 'Type', 'line');
    xCoords = get(lineObjs, 'XData') ;
    for lineIdx = 1:length(xCoords)
        if (length(xCoords{lineIdx}) ~= 2), continue; end
        set(lineObjs(lineIdx), 'XData', xCoords{lineIdx} + [0 figParams.legendLineTweak])
    end
    
    FigureSave(fullfile(outputDir,[mfilename '_ConvertMmToAngle']),mmToAngleFig,figParams.figType);
end

%% Save validation data
UnitTest.validationData('validateDataStruct', data);

end



##### SOURCE END #####
--></body></html>